# C++

##  可调用对象

C++11引入的新概念，可以像函数调用方式（使用括号运算符**`()`**进行调用）触发调用的对象就是**可调用对象（Callable Objects）**。其实可调用对象只是对C++98标准中一些调用方式进行了总结和扩展。  

在C++98标准中，可被通过函数方式调用的对象有3个，分别是**普通函数，函数指针，仿函数**。C++11中增加了**lambda表达式、bind生成对象和function对象**。

所以C++11可调用对象总计**6种**，他们分别是普通函数，函数指针，仿函数（函数对象），bind生成对象，lambda表达式和function对象


- **普通函数**  

  即普通意义上的函数，包括函数名、返回值、输入/出参数和函数体

  ```c++
  bool isEven(int value) // 接收一个参数的函数，返回值为bool类型，也称一元谓词
  {
      return (value % 2 == 0); // 判断是否为偶数
  }
  std::vector<int> vec{2, 5, 9, 10, 11};
  auto res = std::find_if(vec.begin(), vec.end(), isEven); // 返回第一个满足条件的迭代器
  ```

  **`isEven`**就是普通函数式的可调用对象

- **函数指针**

  函数指针指向的是**函数而非对象**。函数指针指向某种特定类型。可以**多次绑定**，即一个函数指针可指向多个普通函数。只要两者具有**相同的函数签名格式**（即有相同的输入/出参数，返回值）。例如：

  ```c++
  bool isEven(int value)
  {
      return (0 == value % 2);
  }
  using EvenDecide = bool(*)(int value); // 函数指针类型 EvenDecide 指向返回值为bool，参数为int的函数
  std::vector<int> vec{2, 5, 9, 10, 11};
  
  EvenDecide evenDecide = isEven;  // 当将函数名作为一个值使用时，该函数自动转换为指针
  EvenDecide evenDecide = &isEven; // 与上面是等价的赋值语句，自动转换成函数指针，无需取地址符(&)
  
  auto res = std::find_if(vec.begin(), vec.end(), evenDecide);  // 可以直接函数指针调用该函数，无需提前解引用(*)
  auto res = std::find_if(vec.begin(), vec.end(), *evenDecide); // 与上面是等价调用
  ```

  函数指针作为**形参**：不能定义函数类型的形参，但是形参可以是函数指针：

  ```C++
  void useEven(int a, bool pFunc(int value)); // 第二个参数是函数类型，实际上会自动转为对应的函数指针
  void useEven(int a, bool (*pFunc)(int value)); // 与上面等价，显示地将形参定义为函数指针
  ```

- **仿函数/函数对象**（function objects）

  仿函数其实就是**重载了`operator()`运算符的类对象**。可以视为一个一般的函数，只不过这个函数功能是在一个类中的运算符operator()中实现，是一个函数对象，它将函数作为参数传递的方式来使用。（行为类似函数，故称仿函数）。实际上就是创建一个类，该类重载了operator()运算符，使得***类的实例可以像函数一样被调用***。这允许你在函数对象内部保存状态，并在调用时执行操作。

  ```C++
  class EvenJudge
  {
  public:
      bool operator() (int value) // 重载函数调用运算符，使得该类的实例成为仿函数，可被调用
      {
          return (0 == value % 2);
      }
  };
  
  std::vector<int> vec{ 2, 5, 9, 10, 11 };
  
  EvenJudge evenJudge; // 仿函数/函数对象
  
  // 1. 通过构造该类的临时对象，调用operator()重载函数
  auto res1 = std::find_if(vec.begin(), vec.end(), EvenJudge());
  // 2. 通过对象，隐式调用operator()重载函数
  auto res2 = std::find_if(vec.begin(), vec.end(), evenJudge);
  ```

  **优势：**

  1. 函数对象可以包含成员变量，从而携带状态。这使得它们在需要保持某些数据或配置的情况下非常有用，而普通函数和函数指针无法实现这一点

  				2. 函数对象比函数指针的执行速度快，函数指针是通过地址调用，而函数对象是对运算符operator进行自定义来提高调用的效率
  				2. 函数对象广泛应用于STL算法、回调函数等场景中

- **lambda表达式**

  lambda是**匿名的函数对象**，可以捕获外部变量并在函数内部使用

  可以将lambda表达式视为包含公有`operator()`的匿名结构(或类)，编译器见到下面的lambda表达式时：

  `[](int value) -> bool {return (0 == value % 2);}`   `-> bool`为指定返回类型，可以省略，但函数体包含**多行代码**时，必须**显示指定**返回类型

  自动将其展开为**类似函数对象**的表示：

  ```c++
  class NoName
  {
  public:
      bool operator() (int value) // 重载函数调用运算符，使得该类的实例成为仿函数，可被调用
      {
          return (0 == value % 2);
      }
  };
  ```

  1. 通过捕获列表来使用所在区块中的变量（局部变量）

  ```C++
  void foo()
  {
      string m_s = "hello";  
      //值捕获，m_i和m_s是变量拷贝
      auto bar = [m_s]{return m_s;};
      m_s = "hello world";
      //结果是hello,foo里面储存的是捕获时的副本(按值传递)
      std::cout << bar(); // "hello"
      //引用捕获，m_i和m_s是变量本身(按引用传递)
      string m_s = "hello";
      auto bar = [&m_s]{return m_s;};
      m_s = "hello world"; 
      //结果是hello world
      std::cout << bar(); // "hello world"  
      //对作用域内所有变量采用值捕获
      auto baz = [=]{return m_s;};
      //对作用域内所有变量采用引用捕获
      auto baz = [&]{return m_s;};
  }
  ```

  2. lambda表达式有输入/出参数，返回值，函数体，唯独没有函数名，所以lambda表达式**不能通过类型名来显示声明对象**。但是可以使用auto和类型推导。例如：

  ```C++
  auto fnIsEven = [](int value)->bool {
          return (0 == value % 2);
  };
  std::vector<int> vec{ 2, 5, 9, 10, 11 };
  auto res1 = std::find_if(vec.begin(), vec.end(), fnIsEven);
  auto res2 = std::find_if(vec.begin(), vec.end(), [](int value) {
         	return (0 == value % 2));
  });
  ```

  3. **可变lambda（Mutable Lambda）**默认情况下，lambda表达式捕获的变量是const。如果需要修改捕获的变量，可以使用**mutable**关键字

  ```c++
  #include <iostream>
  
  int main() {
      int n = 10;
  
      auto increment = [n]() mutable {
          n++;
          std::cout << "n inside lambda: " << n << std::endl;
      };
  
      increment(); // 输出: n inside lambda: 11
      std::cout << "n outside lambda: " << n << std::endl; // 输出: n outside lambda: 10
  
      return 0;
  }
  ```

  4. **泛型lambda** C++14引入了泛型lambda表达式，可以使用自动类型推断来定义参数类型

  ```c++
  #include <iostream>
  
  int main() {
      auto add = [](auto a, auto b) {
          return a + b;
      };
  
      std::cout << add(1, 2) << std::endl; // 输出: 3
      std::cout << add(1.5, 2.5) << std::endl; // 输出: 4
  
      return 0;
  }
  ```

  5. **捕获表达式** C++14引入了捕获表达式，使得在捕获时可以直接初始化捕获的变量

  ```c++
  #include <iostream>
  #include <vector>
  
  int main() {
      std::vector<int> vec = {1, 2, 3, 4, 5};
      int factor = 2;
  
      auto multiply = [factor = factor * 2](int value) {
          return value * factor;
      };
  
      for (int value : vec) {
          std::cout << multiply(value) << " "; // 输出: 4 8 12 16 20
      }
  
      return 0;
  }
  ```

- **bind生成对象**

  **`std::bind`**是C++11引入的一个标准库函数，用于**创建可调用对象**，该对象将特定参数绑定到现有的可调用对象（例如函数、函数指针、函数对象或lambda表达式）。**`std::bind`**生成一个新的可调用对象，这个对象可以在以后调用并携带部分或全部参数。它在需要**延迟调用或部分应用参数**的情况下特别有用。 

  基本语法：

  ```c++
  auto boundFunction = std::bind(callable, arg1, arg2, ...);
  // callable：可以是函数指针、成员函数指针、函数对象或lambda表达式。
  // arg1, arg2, ...：可以是实际参数、占位符或其他绑定的参数。
  ```

  **占位符：**

  占位符用于指定在调用绑定函数时传递的参数位置。标准库提供了几个占位符：`_1`：表示绑定函数的第一个参数。`_2`：表示绑定函数的第二个参数 ...

  占位符在`std::placeholders`命名空间中定义，通常通过`using namespace std::placeholders;`来使用它们

  1. **`bind`普通函数**：其实普通函数可以理解为：一个特殊的函数指针，一个const 引用类型的函数指针（一旦绑定永远不许修改）

  ```C++
  bool isEven(int value)
  {
  	return (0 == value % 2);
  }
  
  auto f = std::bind(isEven, std::placeholders::_1); // f 即bind生成的可调用对象 注意有一个占位符
  std::vector<int> vec{ 2, 5, 9, 10, 11 };
  auto res = std::find_if(vec.begin(), vec.end(), f);
  
  // 若发生函数重载，bind需要指明函数类型来确定应该绑定哪个函数
  bool isEven(long long value)
  {
      return (0 == value % 2);
  }
  // 使用 static_cast 明确指定函数的类型，从而消除歧义
  auto f = std::bind(static_cast<bool(*)(long long)>(isEven), std::placeholders::_1); 
  ```

  2. **`bind`函数指针**：

  ```C++
  bool isEven(int value)
  {
  	return (0 == value % 2);
  }
  using EvenDecide = bool(*)(int value); 
  EvenDecide evenDecide = isEven;
  
  auto f = std::bind(evenDecide, std::placeholders::_1); // f 即bind生成的可调用对象
  std::vector<int> vec{ 2, 5, 9, 10, 11 };
  auto res = std::find_if(vec.begin(), vec.end(), f);
  ```

  3. **`bind`函数对象** :

  ```c++
  struct EvenJudge
  	{
      bool operator() (int value) // 重载函数调用运算符，使得该类的实例成为仿函数，可被调用
      {
          return (0 == value % 2);
      }
  };
  
  std::vector<int> vec{ 2, 5, 9, 10, 11 };
  
  EvenJudge evenJudge; // 函数对象
  
  auto f = std::bind(evenJudge, std::placeholders::_1);
  // auto f = std::bind(EvenJudge(), std::placeholders::_1); //上面的等价
  std::vector<int> vec{ 2, 5, 9, 10, 11 };
  auto res = std::find_if(vec.begin(), vec.end(), f);
  ```

  4. **`bind` lambda表达式**：

  ```c++
  auto fnIsEven = [](int value) {
      return (0 == value % 2);
  };
  auto f = std::bind(fnIsEven, std::placeholders::_1);
  std::vector<int> vec{ 2, 5, 9, 10, 11 };
  auto res = std::find_if(vec.begin(), vec.end(), f);
  ```

  5. **`bind`** 类的成员函数：

  ```C++
  class MyClass
  {
  public:
      void display(int value) // 类的成员函数
      {
          std::cout << "Value: " << value << std::endl;
      }
      void display(double value) // 类的成员函数
      {
          std::cout << "Value: " << value << std::endl;
      }
  };
  
  int main()
  {
      MyClass obj;
      auto f = std::bind(&MyClass::display, &obj, std::placeholders::_1); // 记得第二个参数传类实例对象的this指针
      f(11); // 输出：Value::11
  	
      // 若发生成员函数重载，bind需要指明函数类型来确定应该绑定哪个函数
      auto f = std::bind(static_cast<void(MyClass::*)(double)>(&MyClass::display), &obj, std::placeholders::_1>);
      return 0;
  }
  ```

  `bind`的作用在于它可以将所有可调用对象进行**归一化调用**。大大的降低了可调用对象的差异性。可增加程序的**可维护性和扩展性**  

- **function对象**

  **`std::function<>`**是C++11标准引入的类模板，专门用来包装可调用的对象。

  **`std::function` **的模板参数指定了可调用对象的签名，即返回类型和参数类型列表。例如，`std::function<int(int, int)>` 表示一个返回 `int`，并接受两个 `int` 参数的可调用对象。

  因此，有了**`std::function<>`**，不同实现的各种函数对象可以共用同一种调用形式(**call signature**)。

  实例化以后的**`std::function<>`**，例如`std::function<int(int)>`，可以被理解为是某种**特定调用形式**的一个***容器***。

  ```C++
  int add(int a, int b) {
      return a + b;
  }
  struct Add {
      int operator()(int a, int b) const {
          return a + b;
      }
  };
  using pADD = int(*)(int a, int b);
  pADD padd = add;
  int main() {
      std::function<int(int, int)> func = add; // 包装普通函数
      std::function<int(int, int)> func = [](int a, int b) -> int{return a + b;}; // 包装lambda表达式
      std::function<int(int, int)> func = Add(); // 包装函数对象(仿函数)
      std::function<int(int, int)> func = padd; // 包装函数指针
      auto func_bind = std::bind(add, std::placeholders::_1, std::placeholders::_2);
      std::function<int(int, int)> func5 = (func_bind); // 包装bind对象
      std::cout << func(2, 3) << std::endl; // 输出: 5
      return 0;
  }
  ```

## 函数签名

在C++编程中，**函数签名（Function Signature）**是函数唯一标识的一部分，用于**区别不同的函数**。函数签名包括**函数的名称和参数类型列表**，但***不包括***返回类型、参数名称和参数的默认值。

函数签名的**组成部分**：1. 函数名称：函数的标识符。 2. 参数类型列表：函数参数的类型及其顺序。
函数签名用于在**函数重载和模板实例化**时区别不同的函数。它在编译过程中**帮助编译器确定应该调用**哪个具体的函数。

```C++
void func(int a); 		    // Signature：func(int)
void func(double b);        // Signature：func(double)
void func(int a, double b); // Signature：func(int, double)
```

## 线程创建

### 调用约定（Calling Convention）

用于指定函数如何**接收参数和返回值**，以及函数调用时**堆栈的管理方式**

为什么要用： 调用约定对于函数如何**传递参数、管理堆栈以及返回值的方式**进行规范化。不同的编译器、平台或函数库可能会使用不同的调用约定。使用明确的调用约定可以确保在不同编译单元或不同语言之间进行一致且正确的函数调用。

- **`__cdecl`**  C和C++编程中，默认的调用约定，这是大多数编译器在没有指定其他调用约定时所使用的默认方式，尤其是在x86架构的Windows平台上

  1. **参数传递顺序**：参数***从右向左***传递。这意味着最右边的参数首先被压入堆栈。
  2. **堆栈清理**：***调用者***负责清理堆栈（Caller cleans the stack）。在函数返回后，调用函数的代码负责从堆栈中移除传递的参数。
  3. **函数名称修饰**：使用前导下划线和原名，例如函数 `foo` 会被修饰为 `_foo`
  4. **可变参数支持**：支持可变参数函数（如 `printf`）

- **`__stdcall`**：参数***从右向左***传递，由***被调用者***清理堆栈。常用于Windows API函数，函数名称修饰：前缀+下划线，后缀加@和参数的字节数(十进制)

  ​						如：`void __stdcall myFunction(int a, double b);`会被修饰为：`_myFunction@12`

- **`__thiscall`**：C++类的**成员函数**默认使用的调用约定，`this`指针通过寄存器传递，其他参数从右向左传递

- **`__fastcall__`**：部分参数通过寄存器传递，减少堆栈操作，提高调用效率

### **`pthread_create()`**

Linux平台上使用**`pthread_create`**这个API来创建线程，其函数签名如下：

```C++
int pthread_create(pthread_t *thread, 
				   const pthread_attr_t *attr,
                   void *(*start_routine) (void *), 
                   void *arg);
```

其中：

return: 如果成功创建线程，返回0；如果创建失败，则返回响应的错误码，常见的错误码有`EAGAIN`：资源暂时不可用，如：尝试**非阻塞地**读取一个**空的**非阻塞套接字时、`EINVAL`：无效的参数、`EPERM`：无权限操作

para1: **输出参数**，如果线程创建成功，通过这个参数可以得到创建成功的**线程ID**

para2: 指定了该线程的**属性**，一般设置为NULL，表示使用默认属性

para3: **线程函数指针**，调用方式必须是**`__cdecl`**，必须具有如下原型：`void * function (void *)` 即返回`void*`且参数`void*`

para4：通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个**`void*`**类型，可以方便我们最大化地传入**任意多**的信息给线程函数

### `CreateThread()`

Windows上创建线程使用**`CreateThread`**，其函数签名如下：

```C++
HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  SIZE_T                  dwStackSize,
  LPTHREAD_START_ROUTINE  lpStartAddress,
  LPVOID                  lpParameter,
  DWORD                   是一个32位无符号整型（DWORD），一般设置为0，表示创建好线程后立即启动线程的运行,
  LPDWORD                 lpThreadId
);
```

其中：

return: Windows上使用**句柄**（HANDLE类型）来管理线程对象，句柄本质上是**内核句柄表中的索引值**。如果成功创建线程，返回该线程的句柄；如果创建失败，返回NULL

para1：线程的安全属性，一般设置为NULL

para2：线程的栈空间大小，单位为字节数，一般指定为0，表示使用默认大小。

para3: **线程函数指针**，为线程函数，其类型是**`LPTHREAD_START_ROUTINE`**，这是一个函数指针类型，其定义如下:

`typedef DWORD ( __stdcall *LPTHREAD_START_ROUTINE )(LPVOID lpThreadParameter);`   

即windows下的线程函数，返回值为 `DWORD`，调用方式必须是`_stdcall`，参数类型必须为`LPVOID`

para4：通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个**`void*`**类型，可以方便我们最大化地传入**任意多**的信息给线程函数

para5：是一个32位无符号整型（`DWORD`），一般设置为0，表示创建好线程后立即启动线程的运行

para6：**输出参数**，线程创建成功返回的线程ID，这也是一个32位无符号整数（`DWORD`）的指针（`LPDWORD`）

```
# define WINAPI __stdcall
# define CALLBACK __stdcall
typedef void* LPVOID;
typedef unsigned long DWORD; // 常用来保存地址或者存放指针 一个word是2字节，double word就是4字节，也就是32bit的无符号整数
typedef unsigned long* LPDWIRD;
```

### `std::thread`

无论是Linux还是Windows上创建线程的API，都有一个非常不方便的地方，就是线程函数的签名必须是**固定的格式**（参数个数和类型、返回值类型、调用约定都有要求）。C++11新标准引入了一个新的类**`std::thread`**（需要包含头文件`<thread>`），使用这个类可以将**任何签名形式**的函数（**可调用对象**）作为线程函数。

```C++
// 函数作为线程函数
void foo(int x) {
    std::cout << "foo: " << x << std::endl;
}

int main() {
    // 使用函数作为线程函数
    std::thread t1(foo, 42); // 输出：foo: 42

    // 使用 lambda 表达式作为线程函数
    int y = 100;
    std::thread t2([&]() { // 输出：lambda: 100
        std::cout << "lambda: " << y << std::endl;
        });

    t1.join(); // 阻塞等待该线程结束
    t2.join(); // 阻塞等待该线程结束

    return 0;
}
```

- 一些**接口**：

![image-20240601160308984](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745025.png) 

- 注意如何按**引用传参**：

```C++
#include <iostream>
#include <thread>

void func(int& n) {
    ++n;
}

int main() {
    int value = 42;
    std::thread t(func, std::ref(value)); // 引用传参
    t.join();
    std::cout << "Value after thread execution: " << value << std::endl;
    return 0;
}
```

- 线程任务的移动和交换  

  没有两个 **`std::thread`** ***对象***会表示同一执行线程，因为 **`std::thread`** 是**可移动构造且可移动赋值**，但**不是**可复制构造或可复制赋值的

```C++
auto task(){/* 某些计算过程 */}
std::thread t1(task);
std::thread t2 = t1; //错误: 线程不可以复制
std::thread t3{t1}; // 错误: 线程不可以拷贝构造

//一次只有一个线程对象负责一个任务。但是，与线程对象关联的任务是可移动的：
std::thread t4 = std::move(t1); //正确: t4现在运行task，t1变成一个空对象
```

​		**`swap()`** 方法用于交换两个 **`std::thread`** 对象的内容。这个方法可以用于线程的安全传递，避免手动管理线程资源。

```C++
std::thread t1(func1);
std::thread t2(func2);
t1.swap(t2); // 交换线程 t1 和 t2 的内容
```

- 线程的退出

  **`detach`** 启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束

  - 调用detach表示thread对象和其表示的线程完全分离
  - 分离之后的线程是不在受约束和管制，会单独执行，直到执行完毕释放资源，可以看做是一个daemon线程
  - 分离之后thread对象不再表示任何线程
  - 分离之后`joinable() == false`，即使还在执行

  **`join`**  等待启动的线程完成，才会继续往下执行

### 类的成员函数作为线程函数

- **`pthread_create() `**和 **`CreateThread()`** 的做法：

  假定一个类的成员函数`threadFunc()`

  ```C++
  class CThread
  {
  public:
      Thread();
      ~Thread();
  
      void start();
      void stop();
  
      void* threadFunc(void* arg); // 实例方法
  };
  ```

  无论是类的实例方法（非静态成员函数）还是静态方法（静态成员函数），C++编译器在编译时都会将这些函数”翻译“成**全局函数**，即去掉类的域限制。对于实例方法，为了保证类方法的正常功能，C++编译器在翻译时，会将类的实例对象地址（也就是**this指针**）作为第一个参数传递给该方法，也就是说，翻译后的`threadFunc`的签名变成了如下形式（伪代码）

  ```c++
  void* threadFunc(Thread* this, void* arg);
  ```

  这样的话，就不符合**线程函数签名要求**了。因此如果使用类方法作为线程函数则***只能是类的静态方法而不能是类的实例方法***。

  如果不使用C++11的语法，那么线程函数只能使用类的静态方法，且函数签名必须符合线程函数的签名要求。如果是类的静态方法，那么就**没法访问类的实例方法及成员**了，为了解决这个问题，我们在实际开发中往往会在创建线程时将当前对象的地址（**this**指针）传递给线程函数，然后在线程函数中，将该指针**转换成原来的类实例**，再通过这个实例就可以访问类的所有方法了。

  ```C++
  class CThread
  {
  public:
      CThread();
      ~CThread();
      
      static void* ThreadEntry(void* arg) // 线程入口函数
      {
          CThread* thiz = (CThread*)arg;
          thiz->threadFunc();
      }
      void* threadFunc(void* arg); // 实例方法
  };
  pthread_create(&m_thread, &attr, &CThread::ThreadEntry, this); // 传this指针给线程入口函数，然后在函数中执行真正的工作函数
  ```

- **`std::thread`** 的做法：

  如果是使用C++11的**`std::thread`**类就没有这个限制，即使类成员函数是类的实例方法也可以，但是必须**显式**地将线程函数所属的类对象实例指针（在类的内部就是this指针）作为**构造函数参数**传递给**`std::thread`**，还是需要传递类的this指针，这在本质上是一样的

  ```C++
  class CThread
  {
  public:
      Thread();
      ~Thread();
  
      void* threadFunc(void* arg); // 实例方法
  };
  CThread thread;
  std::thread t(&CThead::threadFunc, &thread, arg); // 传this指针
  ```

## 智能指针

**为什么**要有智能指针：

C++中引入智能指针的主要目的是为了解决**动态内存管理**的问题（C++不像Java等语言有垃圾回收机制 C+对性能要求极高，所以没有垃圾碎片回收机制，对于内存的释放要特别小心）。传统的指针（**裸指针**）在使用时需要手动分配和释放内存，容易出现**==内存泄漏==（未 `delete`）和==悬挂指针==（未 `ptr = nullptr`）**等问题。智能指针通过封装裸指针，并提供自动内存管理功能，使得内存资源可以更安全、高效地管理。基于**`RAII`**思想，我们把指针托管给一个对象，利用对象的生命周期来管理指针。

智能指针的**关键和难点**是处理**==拷贝==** (即在智能指针模板类中对**拷贝构造函数和赋值重载函数**的设计)

### `auto_ptr`

在智能指针被复制时，将对象的所有权**转移**给目标指针，并**重置**原来的指针(**破坏性复制**)

1. 拷贝构造和赋值运算不能接收 **const引用**， 因为内部会重置源智能指针
2. 不适用于 STL 容器，因为破坏性复制导致源指针失效
3. 不支持对象数组的内存管理

```c++
// 管理权转移，转移后不能使用源对象
auto_ptr(auto_ptr& ap)                 // auto_ptr的拷贝构造函数
    :ptr(ap.ptr)
{
    ap.ptr = nullptr;                  // 破坏性复制
}

auto_ptr<T> operator=(auto_ptr<T>& ap) // auto_ptr 的赋值重载函数
{
    if (ptr != ap.ptr)
    {
        ptr = ap.ptr;
        ap.ptr = nullptr;              // 破坏性复制
    }
    return ptr;
}
```

### `unique_ptr`

1. 独占资源所有权，且禁止拷贝构造与赋值重载(但是实现了移动构造与移动赋值，故有2)

   ```C++
   unique_ptr(const unique_ptr<T>& up) = delete; 				// 删除拷贝构造
   unique_ptr<T>& operator=(const unique_ptr<T>& up) = delete; // 删除赋值重载
   ```

2. 支持**右值引用**的拷贝构造与赋值重载(即支持**移动构造与移动赋值**，move_only)，支持**函数返回值**赋值，本质还是右值引用

3. 支持对象数组的管理

```c++
std::unique_ptr<int> func()
{
	std::unique_ptr<int> ptr(new int(10));
	return ptr;
}

std::unique_ptr<int> ptr1(new int(5));
std::unique_ptr<int> ptr2(ptr1);	    // 错误！不支持拷贝构造
std::unique_ptr<int> ptr3 = ptr1;	    // 错误！不支持赋值重载

std::unique_ptr<int> ptr2(std::move(ptr1));  // 正确，支持移动构造，语句结束后 ptr1=nullptr
std::unique_ptr<int> ptr3 = std::move(ptr1); // 正确，支持移动赋值，语句结束后 ptr1=nullptr

ptr1 = func(); // 正确，支持函数返回值赋值(本质还是移动赋值)

std::unique_ptr<int[]> uptr(new int[10]); // 支持对象数组的管理
```

 4. 使用`std::make_unique`, 用于创建一个 `std::unique_ptr` 智能指针，并将其指向一个新分配的对象

    好处：a. **异常安全**：如果在构造对象时发生异常（比如在构造参数时），已分配的内存会被自动回收，这样就不会发生内存泄漏

    ​			b. **简洁的语法**：使用 `std::make_unique` 能用一行代码完成智能指针的创建和对象的初始化

    ​			c. **避免使用裸指针**：使用 `std::make_unique` 可以减少对 `new` 和 `delete` 的直接调用，避免裸指针的使用，使代码更现代化和安全

```C++
std::unique_ptr<int> ptr1 = std::make_unique<int>(5);
std::unique_ptr<int[]> uptr = std::make_unique<int[]>(10); // 数组的智能指针，数组中有10个int
```

### `shared_ptr`

1.  允许多个智能指针可以指向同一块资源，并且能够保证共享的资源只会被释放一次

2. 通过**==引用计数==**来实现，多个`shared_ptr`对象之间共享资源：（**引用计数存放在==控制块==中，其中还有weak count、自定义删除器等**）

   a. 内部有一个成员变量`long int* _pcount`，它指向一块**存储引用计数**的空间，引用计数用来记录该份资源被几个对象共享

   b. 当进行拷贝构造or赋值重载时，引用计数+1，即：`++(*_pcount)`

   c. 当一个`shared_ptr`对象被销毁时（调用析构函数），析构函数内就会将该计数减1,即 `--(*_pcount)`

   d. 如果引用计数减为0后，则表示自己是最后一个使用该资源的`shared_ptr`对象，必须释放资源

   e. 赋值重载：①`ptr1 = ptr1`，自赋值不作处理; ②`ptr1 = ptr2`，若`ptr1`和`ptr2`指向**同一**块空间, 不作处理， 若指向**不同**空间：将`ptr1`的引用计数`-1`     -> 判断是否需要释放原资源 -> 将`ptr1` 指向`ptr2`的资源 -> `ptr2`的引用计数`+1` 		

```c++
std::shared_ptr<int> ptr1 = std::make_shared<int>(10); // *_pcount = 1
std::shared_ptr<int> ptr2(ptr1);					   // *_pcount = 2
std::shared_ptr<int> ptr3 = ptr1;					   // *_pcount = 3
```

 	3. **循环引用**问题：两个或多个对象相互引用，或者⼀些复杂的数据结构，如双向链表中，存在多个引⽤路径等情况下，可能会存在循环引用问题，导致资源无法
 	 被释放掉。

```C++
struct ListNode
{
	std::shared_ptr<ListNode> _pre;
	std::shared_ptr<ListNode> _next;
};

int main()
{
	std::shared_ptr<ListNode> node1 = std::make_shared<ListNode>();
	std::shared_ptr<ListNode> node2 = std::make_shared<ListNode>();

	node1->_next = node2;
	node2->_pre = node1;
	printf("node1 count is: %d\n", node1.use_count()); // node1 count is: 2
	printf("node2 count is: %d\n", node2.use_count()); // node2 count is: 2

	return 0;
}
```

### `weak_ptr`

1. `weak_ptr`不参与资源的管理和释放，可以使用`shared_ptr`或`weak_ptr`来构造或赋值，但是不能直接使用裸指针来构造`weak_ptr`对象
2. `weak_ptr`在进行拷贝构造和赋值时，不增加引用计数，由于`weak_ptr`不参与资源管理，也不需要显示定义析构函数来释放资源
3. 没有`operator*`函数和`operator->`成员函数，不具有一般指针的行为
4. 严格意义上并不是智能指针，其出现，就是为了解决`shared_ptr`的循环引用问题。

```c++
struct ListNode
{
	std::weak_ptr<ListNode> _pre;
	std::weak_ptr<ListNode> _next;
};

int main()
{
	std::shared_ptr<ListNode> node1 = std::make_shared<ListNode>();
	std::shared_ptr<ListNode> node2 = std::make_shared<ListNode>();

	node1->_next = node2;
	node2->_pre = node1;
	printf("node1 count is: %d\n", node1.use_count()); // node1 count is: 1
	printf("node2 count is: %d\n", node2.use_count()); // node2 count is: 1

	return 0;
}
```

### 自定义删除器**（Custom Deleters）**

1. 可以为 `std::unique_ptr` 和 `std::shared_ptr` 提供一个**自定义删除器**，这在需要特殊逻辑来销毁对象时很有用，例如释放非内存资源
2. 这个自定义删除器可以是**函数指针**、**仿函数**、**lambda表达式** 等可调用对象
3. 举例：指向**数组**的智能指针，析构时应该使用`delete[]` 、指向**文件**的智能指针，析构时应该使用`fclose()` 

```c++
struct ListNode
{
	std::weak_ptr<ListNode> _pre;
	std::weak_ptr<ListNode> _next;
};

int main()
{
	std::shared_ptr<ListNode> ptr1(new ListNode[10], [](const ListNode* arry) // lambda表达式做自定义删除器
		{
			printf("delete[] for array!\n"); // delete[] for array!
			delete[] arry; });
	return 0;
}
```

### `shared_ptr`的线程安全

**线程不安全的实质就是相同的代码，不同线程执行先后不同结果不同**

1. 多线程代码操作的是同一个`shared_ptr`的对象(**赋值)**是**线程不安全**的

```c++
// 由于赋值操作涉及原内存释放、修改指针指向等多个修改操作，其过程不是原子操作，因此对shared_ptr进行并发赋值不是线程安全的
std::shared_ptr<int> global_sp = std::make_shared<int>(10);
std::shared_ptr<int> global_sp2 = std::make_shared<int>(20);

void fn(std::shared_ptr<int>& sp) { // 引用传参，故操作的是同一个shared_ptr对象
	 sp = global_sp;
}
void fn2(std::shared_ptr<int>& sp) {
	sp = global_sp2;
}
int main() {
	std::shared_ptr<int> sp1 = std::make_shared<int>(5);
	std::thread t1(fn, std::ref(sp1)); 
	std::thread t2(fn2, std::ref(sp1));
	
	t1.join();
	t2.join();

	printf("sp1 = %d\n", *sp1); // sometimes 20 sometimes 10

	return 0;
}
```

2. 多线程代码操作的不是同一个`shared_ptr`的对象(**复制**)，但不同的`shared_ptr`指向了相同的内存，此时是线程安全的（引用计数是线程安全的）

```c++
// 进行并发拷贝，对数据指针和控制块指针仅进行读取并复制，然后对引用计数进行递增，而引用计数增加是原子操作。因此是线程安全的
std::shared_ptr<int> global_sp = std::make_shared<int>(10);
std::shared_ptr<int> global_sp2 = std::make_shared<int>(20);

void fn(std::shared_ptr<int> sp) { // 注意这里没有引用传参，故是复制，操作的不是同一个share_ptr对象
	 sp = global_sp;
}
void fn2(std::shared_ptr<int> sp) {
	sp = global_sp2;
}
int main() {
	std::shared_ptr<int> sp1 = std::make_shared<int>(5);
	std::thread t1(fn, sp1);
	std::thread t2(fn2, sp1);
	
	t1.join();
	t2.join();

	printf("sp1 = %d\n", *sp1); // always 5

	return 0;
}
```

3. `shared_ptr`本身不是一个线程安全的STL，因此并发读写对应内存区域是不安全的

```C++
std::shared_ptr<int> sp = std::make_shared<int>(0);
void fn() {
	for (int i = 0; i < 10000; i++) {
		(*sp)++;
	}
}

int main() {
	
	std::thread t1(fn);
	std::thread t2(fn);
	
	t1.join();
	t2.join();

	printf("sp1 = %d\n", *sp); // sometimes: 20000 sometimes:16625

	return 0;
}
```

### `enable_shared_from_this`

1. 什么时候会创建控制块

```C++
// a. std::make_shared会创建控制块。
// b. 从 std::unique_ptr 上构造出 std::shared_ptr的时候，会创建控制块。
// c. 从原始指针上构造 std::shared_ptr的时候会创建控制块
```

2. `this`指针作为`std::shared_ptr`构造函数实参的时候可能导致创建多个控制块，析构时导致非法行为

```C++
class test
{
public:
	test() {}
	~test() {
		printf("Destructor!\n");
	}
	std::shared_ptr<test> getptr() {
		return std::shared_ptr<test>(this);
	}
};

int main() {
	std::shared_ptr<test> sp = std::make_shared<test>(); // 创建了一个管理 this 的控制块
	std::shared_ptr<test> sp2 = sp->getptr(); // 又创建了一个管理 this 的控制块
	// 析构时会 double free,以下为打印输出：
	// Destructor!
	// double free or corruption(out)
	// Aborted

	return 0;
}
```

3. 针对以上问题，为了避免**double free** 同时能方便地在类的成员函数中获取管理类对象的`shared_ptr`,使用`std::enable_shared_from_this`这个模板类

   `std::enable_shared_from_this`定义了一个成员函数：`shared_from_this()`，它会创建指向当前对象的`std::shared_ptr`，会去关联同一个已经创建的**控制块**，解决了多个控制块的问题

```c++
class test: public std::enable_shared_from_this<test> // 继承 std::enable_shared_from_this<>这个模板类
{
public:
	test() {}
	~test() {
		printf("Destructor!\n");
	}
	std::shared_ptr<test> getptr() {
		return shared_from_this();
	}
};

int main() {
	std::shared_ptr<test> sp = std::make_shared<test>(); // 创建了一个管理 this 的控制块
	std::shared_ptr<test> sp2 = sp->getptr(); // p2 与 p1 共享一个控制块，不会创建第2个
	// 析构时不会 double free,以下为打印输出
	// Destructor!

	return 0;
}
```

## static & const

**static**：修饰符，用于控制变量的**存储方式和可见性**

- **控制存储方式**：static被引入以告知编译器，将变量存储在程序的**静态存储区**而非**栈上空间**（故==**生命周期**==也被改变了）
- **控制可见性**：把变量的可见范围限制在编译单元中，使它成为一个内部连接，不具备外部连接属性，在外部**extern**也没用

==以下五个用处，前 3 个 C/C++ 共享，后 2 个 C++ 独占==

- **静态局部变量**：用于函数体内部修饰变量，这种变量的生命周期长于该函数(在**数据段**)，随着函数的第一次调用而初始化(仅一次)，却不随函数调用结束而销毁

- **静态全局变量**：修饰全局变量，表示该变量只在本文件可见(控制可见性)，不具有全局变量的外部连接属性，在其他文件中可以定义相同名字的变量

- **静态函数**：与静态全局变量类似，不能被外部文件所用，其他文件中可以定义相同名字的函数，不会冲突

- **静态成员变量**：生命周期长于该类的对象(instance)， 类的所有对象**共享一份**静态成员变量(静态存储区)，并**不占用**类对象的内存空间。故静态成员变量也称类变量，普通成员变量称实例变量；因为与对象无关，定义时就要分配内存，不能在类声明中定义

- **静态成员函数**：被类的所有对象**共享**；可以直接用`A::func()`调用；不能访问非静态成员变量or函数(**无this指针**)，但是非静态可以访问静态

  ​                           因为**先于类的对象而存在**，怎么可能知道后面发生的事呢？ 而对象实例化时是知道类声明中所有事的		

**const**：修饰符，告诉编译器指定了一个变量在初始化后**不能被修改**的特性，其内存分配取决于其声明的位置和作用域

- **顶层const**：指针本身就是一个常量		

  ```c++
  int * const a = 10; // const的左结合
  ```

- **底层const**：指针指向一个常量

  ```C++
  const int *a = 10; 
  ```

- **const成员函数**：本质上是修饰了**this指针**

  ```c++
  class A
  {
      public:
      void func () {} // 普通成员函数默认签名为：(A* const this, ...), 即接收一个顶层const的this指针作为参数 
      void func2 () const {} // const成员函数默认签名为：(const A* const this, ...), 即接收一个顶层+底层const的this指针作为参数
  }
  A a; // 此时 a 的this指针类型为 A* const this (默认顶层const)
  const A b; // 此时 ab的this指针类型为 const A* const this (顶层+底层const)
  
  a.func(); // OK, A* const this 传参给 func()
  a.func2(); // OK, A* const this 传参给 func2()
  
  b.func(); // fail! const A* const this 传参给 func() 会被认为有修改底层const的风险
  b.func2(); // OK const A* const this 传参给 func2()
  ```

## constexpr volatile mutable	

**constexpr**：真正的常量

- **与const的区别**：const修饰的变量可以在运行时才初始化，而constexpr则一定会在**编译期初始化**。故 constexpr 才是名副其实的**常量**，const 更多表示的是 **read-only** 语义
- **用于指针**：`constexpr int* a = 10;` 与 const 不同，constexpr 只有**顶层 const **语义，即这里是修饰指针 a 表明 a 是常量，而非指针指向的对象

**volatile**：直接从从**原始内存地址**读取，而非CPU的寄存器， 类型修饰符，**确保指令不会被编译器的优化而忽略**

```c++
int main()
{
	int i = 10; // volatile int i = 10; // 每次都会从 i 的原始内存地址中取值
	int a = i;

	printf("%d", i);

	//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道
	__asm
	{
		mov dword ptr[ebp - 4], 20h
	}
	int b = i;
	printf("i=%d", b);
	return 0;
}
// debug版本模式下运行，输出 i = 10 i = 32
// release版本模式下运行，输出 i = 10 i = 10
// 编译器干了什么：由于编译器发现两次从 i 读数据的代码之间的代码没有对 i 进行过操作，它会认为只需要从内存中读取一次就够了，自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错
```

**mutable**：

- 需要在 const 成员函数中修改一个成员变量的值，需要将这个成员变量修饰为 **mutable**。即用 mutable 修饰的成员变量不受 const 成员方法的限制

```c++
class A
{
public:
	static int a;
	mutable int b = 20; // 需要在 const 成员函数中改变一个成员变量的值
	void func() const {
		b++; 
	}
};
```

- 需要在 lambda 函数中使用改变了捕获参数的值，但又不想将这个改变传回源捕获参数，按值传递的话需要在函数体内**复制**一次，用**mutable**就不用

![image-20240611171903964](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744921.png) 

## auto decltype			

```c++
auto varname = value; // auto的语法格式    varname表示变量名，value 表示赋给变量的值， exp表示一个表达式，[]表示可选
decltype(exp) varname [= value]; // decltype的语法格式
```

- `auto `  要求变量**必须初始化**，也就是在定义变量的同时必须给它赋值，因为 `auto`  根据变量初始值来推导出变量类型，如果不初始化，变量的类型也就无法推导；`decltype` 则不要求，初始化与否都不影响变量的类型
- **推导规则不同**：`auto` 将变量的类型和初始值绑定在一起，而 `decltype` 将变量的类型和初始值分开；虽然 `auto` 的书写更加**简洁**，但 `decltype` 的使用更加**灵活**
- **应用场景不同**：`auto` 通常用于变量声明时，**简化类型定义**，特别是当类型名较长或复杂时
  `decltype` 常用于需要**精确类型匹配**的场景，如模板元编程、泛型编程中，以及定义依赖于表达式类型的变量
- **对 `const` 限定符的处理**：

```c++
// 在推导变量类型时，auto 和 decltype 对 cont 的处理是不一样的。decltype 会保留限定，而 auto 有可能会去掉限定
// a. 如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。
// b. 如果表达式的类型是指针或者引用，auto 将保留 cv 限定符
const int n1 = 0;
auto n2 = n1; // n2 -> int
decltype(n1) n3; // n3 -> const int

const int *p1 = &n1;
auto p2 = p1; // p2 -> const int *
decltype(p1) p3; // pr -> const int *
```

- **对引用的处理**：

```c++
// decltype 会保留引用类型
// auto 会抛弃引用类型，直接推导出它的原始类型
int n = 0;
int &r1 = n;
auto r2 = r1; // r2 -> int
decltype(r1) r3; // r3 -> int&
```

- **总结**：
  a.  `auto` 书写格式比 `decltype` 简单，但推导规则复杂，有时候会改变表达式的原始类型；而 `decltype` 比较纯粹，一般会坚持保留原始表达式的任何类型
  b.  在实际开发中，如果明确知道使用的变量类型，那么使用 `auto`，减少代码量，增加可读性，其他场景使用 `decltype`

## 如何让对象只产生于栈/堆中

```C++
// C++ 创建对象的两种方式：

// 1.静态创建，由编译器为对象在栈空间中分配内存，然后在这片内存空间上调用构造函数创建一个栈对象。这种方式是直接调用类的构造函数
A a; 

// 2.动态创建，用new在堆空间上创建对象，具体过程是首先是执行operator new()函数，在堆空间上分配何时的内存；然后是调用构造函数构造对象，初始化这片内存空间。这种方式是间接的调用类的构造函数
A *p = new A;
```

- **如何只在栈上分配内存**：

a. 使用 `new`， 对象才会建立在堆上。故只需要禁用 `new` 运算符就可以实现类对象只能建立在栈上。

b. `new`是C++内置的运算符，我们不能改变，但可以利用 `new` 总是调用 `operator new()` 这一特性，将 `operator()` 声明为私有即可

![image-20240612165808170](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744404.png) 

- **如何只在堆上分配内存**：

a. 当对象建立在栈上面时, 是由**编译器分配内存空间**的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间

b. 编译器在为类对象分配栈空间时, 会检查类的**析构函数的访问性**(其他非静态函数也会检查)，如果类的析构函数是**私有**的， 则编程器不会在栈空间上为类对象分配内存

c. 因此, 我们只需要**将析构函数设为私有，类对象就无法建立在栈上**

![image-20240612170526683](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744652.png) 

## 多态与虚函数

### 多态的定义

1.  **编译时多态（静态多态）**：也称为**重载多态**。在编译时根据函数或运算符的参数类型来确定调用的具体函数或操作。这种多态性在编译时就已经确定，因此也称为静态多态。C++ 中的函数重载(模板)就是一种编译时多态的表现
2.  **运行时多态（动态多态）**：也称为**覆盖多态**。在运行时根据对象的实际类型来确定调用的具体函数或方法。这种多态性是通过**虚函数**实现的，所以也称为动态多态。在基类中声明一个虚函数，在派生类中重新定义它，当通过**基类指针或引用调用该函数时，将根据对象的实际类型来调用相应的函数**

### 虚函数的定义与作用

在C++中，虚函数是为了实现**多态性**而设计的。通过将基类中的成员函数声明为**虚函数**，可以在派生类中**重新定义(重写)**该函数，并且在**运行时**根据对象的实际类型来调用相应的函数，从而实现多态

### 虚函数的实现原理

虚函数的实现依赖于**虚函数表（vtable）和虚表指针（vptr）**。每个包含虚函数的类都有一个虚函数表（**one class one table**），其中存储了**该类的虚函数的地址**， 即虚函数表就是一个**虚函数指针数组**。同时，每个对象都包含一个指向虚函数表的指针，即虚表指针**（one instance one pointer）**当调用虚函数时，编译器会通过对象的虚指针找到对应的虚函数表，然后根据函数在虚函数表中的**偏移量**来调用相应的函数

- **如何找到虚函数？**
  1.  编译器会给每个虚函数指定一个在虚函数表中的**索引（偏移量）** 每个虚函数的偏移量在基类和派生类中相同，所以可以在编译时确定
  2.  编译器在编译期将虚函数的调用转化为 **`(*p->vptr[1])(p)`**, **() **内获取 **func1** 的地址，然后调用传参 **p**（表示 this 指针）
  3.  运行时根据指针 **p** 指向的是父类对象，那么虚表的内存布局就是父类的，指向子类那就是子类的

- **析构函数为什么要是虚函数？**
  1. 由于基类的多态性，基类指针可以指向派生类的对象，**将析构函数声明为虚函数**，删除该基类的指针，就会调用该指针指向的派生类析构函数，而==**派生类的析构函数又自动调用基类的析构函数**==，这样整个派生类的对象**完全被释放**。
  2. 如果析构函数不被声明成虚函数，则编译器实施**静态绑定**，在删除基类指针时，==**只会调用基类的析构函数而不调用派生类析构函数**==，这样就会造成派生类对象析构不安全，造成==**内存泄露**==。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状态发生，要将基类的析构函数声明为虚函数
- **构造函数可以是虚函数吗？** ---==**不可以**==
  1. 虚函数对应一个虚表指针，**虚表指针其实是存储在对象的内存空间的**。**如果构造函数是虚函数，就需要通过虚函数表中对应的虚函数指针（编译期间生成属于类）来调用**，可对象目前还没有实例化，也即是还没有内存空间，何来的虚指针，所以构造函数不能是虚函数
  2. 虚函数的作用在于通过父类的指针或者引用来调用它的成员函数的时候，能够根据动态类型来调用子类相应的成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以也不需要将其设置为虚函数

### 虚函数的内存布局

虚函数-> .text 									虚函数表->.rodata   			 虚函数指针->跟对象走

- **单继承内存模型**

  ```c++
  struct A
  {
      int ax; // 成员变量
      virtual void f0() {}
      virtual void f1() {}
  };
  
  struct B : public A
  {
      int bx; // 成员变量
      void f0() override {}; // 重写f0
  };
  ```

  ![image-20240613150949586](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131549335.png) 

  ```c++
  // 如果类型 B 中出现了基类型A中没有的虚函数，新的虚函数将会被附加在虚函数表的最后，不会对与基类重合的部分造成影响。例如B中新增加了函数f2()，虚函数表变化如下：
  ```

  ![image-20240613151130318](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131549336.png) 

- 多继承内存模型

  ```c++
  // 假设类型C同时继承了两个独立的基类A和B， 它们的定义关系如下：
  struct A
  {
      int ax;
      virtual void f0() {}
  };
  
  struct B
  {
      int bx;
      virtual void f1() {}
  };
  
  struct C : public A, public B
  {
      int cx;
      void f0() override {}
      void f1() override {}
  };
  ```

  ```C++
  // 与单链继承不同，由于A和B完全独立，它们的虚函数没有顺序关系，即f0和f1有着相同对虚表起始位置的偏移量，不可以顺序排布。
  // 并且A和B中的成员变量也是无关的，因此基类间也不具有包含关系
  // 这使得A和B在C中必须要处于两个不相交的区域中，同时需要有两个虚指针分别对它们虚函数进行索引。 其内存布局如下所示
  ```

  ![image-20240613151446359](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131549337.png) 

### 菱形继承

- **定义**：两个(多个)子类继承同一个父类而又有孙类同时继承这两个子类

  ```c++
  class A {
  public:
      int value;
  };
  
  class B : public A {};
  class C : public A {};
  class D : public B, public C {};
  ```

- **问题**：a. **数据二义性**，编译器不知道要访问的变量到底是哪个子类的  b.**数据冗余浪费内存空间**

- **解决方法**：子类**虚继承**基类，孙类再去继承子类时，就只会保留一份基类成员

  ```c++
  class A {
  public:
      int value;
  };
  
  class B : virtual public A {};
  class C : virtual public A {};
  class D : public B, public C {};
  ```

- **虚继承的底层实现**：虚基类的实现其实就是**产生虚基类表指针 vbptr 与虚基类表 vbtable**。编译器 gcc 的做法是将虚基类放在对象末尾, 在虚表中添加一项, 记录**基类对象在对象中的偏移**, 从而获得其地址

## 左值右值

### 值语义：

- **GC语言**：带有垃圾回收（Garbage Collection, GC）机制的编程语言。垃圾回收是一种自动内存管理的技术，用于在程序运行时自动回收不再使用的内存，以防止内存泄漏和优化内存使用（Java、Python、Go）。大部分变量都是**引用语义**，内存管理交给**GC**
- **C++**：通过**值语义**可以方便直观地控制对象生命周期，让 RAII 用起来更自然(构造时初始化资源，析构函数中释放资源)
- **引用**：即别名，声明时必须初始化其引用哪个对象，通过引用来修改变量值

### 左值：**可以**在等号左边，能够取地址，具名

```c++
int a = 10; 		  // 变量名 
int &a = func(); 	  // 返回左值引用的函数调用
++i = 100; --i = 100; // 前置自增/自减 可以理解为：i = i - 1 ; return i;
(i += 10) = 1000; 	  // 赋值运算或复合赋值运算
(*p) = 100; 		  // 解引用
```

### 右值：**只能**在等号右边，不能取地址，不具名

- **纯右值**：

```c++
int a = 10; // 字面值，这个10就是右值
char* p = "Hello World!"; // 注意这里 "Hello World!" 是左值，存在于常量区，可以取地址
int a = func(); // 返回非引用类型的函数调用
i ++ , i -- ; //  后置自增、自减 可以理解为：int j = i; i = i - 1 ; return j;
a + b; a && b; a > b; // 算数表达式、逻辑表达式、比较表达式
```

- **将亡值**：

```c++
// C++ 11 所引入的与右值引用(移动语义)相关的值类型
// 将亡值用来触发移动构造或移动拷贝，并进行资源转移(避免深拷贝、提高效率)，注意是转移堆上的资源，栈上的资源生命周期是固定的
```

### 引用

- **左值引用**：对左值的引用，可以避免对象拷贝，比如函数传参、函数返回值

```c++
const int& a = 10; // const 左值引用可以指向右值，但存在不能修改的局限
```

- **右值引用**：对右值的引用

```c++
MyClass obj1(10);            	 // 调用带参数构造函数
MyClass obj2 = std::move(obj1);  // 调用移动构造函数(不涉及到深拷贝)
// 注意：此时 obj1 的 data 指针被置为空，obj1 不再拥有原有的资源(被转移了)
// 右值引用可以通过 std::move(v) 可以指向左值
// 我的理解：就是将 v 强转成右值引用类型，然后就可以调用到移动构造函数或者移动赋值运算符来避免深拷贝
```

- **右值引用的作用**：==主要目的就是提高程序运行效率==
  1. 实现**移动语义**：对象赋值时，触发移动构造或移动赋值避免**深拷贝**导致资源的重新分配
  2. 有了移动语义就可以触发移动构造和移动赋值(**传右值引用就会调用移动构造/赋值而非拷贝构造/赋值**)
  3. `std::unique_ptr`：其中删l除了类拷贝构造和赋值运算符重载，但实现了移动构造和移动赋值以及支持函数返回值(还是可以确保只有一个管理对象)，详见上文**智能指针**
  4. 实现完美转发：函数模板可以将自己的参数完美地转发给内部调用地其他函数，让代码保持简洁。不仅能准确地转发参数的值，还能保证被转发的参数的左右值属性不变。借用万能引用，通过引用的方式接收左右属性的值

```c++
void func(int &n){
	printf("lvalue = %d\n", n);
}

void func(int &&n){
	printf("rvalue = %d\n", n);
}

template<typename T>
void revoke(T &&t){ // 万能引用
	// 参数为左值或左值引用, T&& 将转化为 int &
	// 参数为右值或右值引用, T&& 将转化为 int && 
	func(std:forward(T)(t));
}
```

## 线程同步(及其API)

## 编译原理

### 基本过程

| 过程      | 文件                          | 操作                                                         |
| --------- | ----------------------------- | ------------------------------------------------------------ |
| 1. 预处理 | `.i` (文本)                   | 主要用于处理 `#` 开头的代码行，比如对宏做展开，对include的文件做展开，条件编译选项判断，清理注释等<br />`gcc -E foo1.c -o foo1.i` |
| 2. 编译   | `.s` (文本)                   | 使用预处理的输出结果作为输入，进行 **语法分析 词法分析 语义分析 源代码优化 目标代码生成和优化**以后，生成文本格式的平台相关的**汇编代码**(assembly code)<br />`gcc -S foo1.i -o foo1.s` |
| 3. 汇编   | `.o` 可重定位目标程序(二进制) | 将上一步的汇编代码转换成二进制的机器码，称为object code。产生的文件叫做**目标文件**，是**二进制格式**<br />`gcc -c foo1.s -o foo1.o` |
| 4. 链接   | 可执行目标程序(二进制)        | 将多个可重定位文件进行**空间和地址重分配，符号解析和重定位**最终组成一个可执行目标文件<br />`gcc -o foobar foo3.c foo4.c` |

### 目标文件

Linux下的==目标文件==为**`ELF`**格式，主要有三种类型:

a. **可重定位目标文件 .o**：汇编阶段生成 包含**二进制和代码**，可在链接阶段和其它可重定位目标文件链接，生成可执行目标文件

b. **可执行目标文件**: 最终链接生成的文件 可加载到内存执行

c. **共享目标文件 .so**：特殊的目标文件 可以在**运行时被动态链接**加载到内存运行(见下文**动态链接**)

虽然细分了具体类型，但是**文件格式**基本类似都是**ELF格式(Executable Linkable Format，可执行可链接格式)**，主要是**`ELF`头 + 若干段**

![image-20240613121025163](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131211751.png)  ![image-20240613121341346](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448747.png) 

### 链接

**(1) 空间和地址重分配**：本例中`foo1.o`和`foo2.o`中均含有`.text .data`等对应段，链接时会将多个可重定位文件的相似段进行**合并**，如多个`.text`段合并为一个`.text`段, 示意图如下:

![img](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448790.jpeg)

**（2）符号解析和重定位**：在空间和地址分配以后，我们确定了可执行文件各个段以及各个符号的具体**虚拟地址**。接下来需要原来可重定位文件中的**符号**进行解析以及重定位； **强符号**:**函数和已经初始化（包括零值）的全局变量** 如`foo1.c`中的`x y sum main`等    **弱符号:未初始化的全局变量**

### 静态库链接

==**什么是静态库？**==
**可重定位目标文件(.o)**以一种特定的方式**打包**成一个单独的文件，并且在链接生成可执行文件时，从这个单独的文件中“拷贝”它自己需要的内容到最终的可执行文件中。**这个单独的文件，称为静态库**。Linux中通常以 **.a(archive)** 为后缀，存档文件(**.a**)是一组**可重定位目标文件的集合**，并且在文件头部记录了每个可重定位目标文件的**大小和位置**信息

```shell
 gcc -static -o main main.o -lm
```

在上面链接过程中，就会用到系统中的静态库 **libm.a**

特别注意 **`-lm`** 必须放在后面，因为链接器是**从左向右**扫描，遇到未解析的符号记住，在静态库中找到未解析的符号就提取

**`static`** 参数，告诉链接器应该使用**静态链接**，**`-lm`** 参数表明链接 **libm.a** 这个库（类似的，如果要链接 **libxxx.a** ,使用 **`-lxxx`** 即可）。由于 **main.c** 中使用了**libm.a** 中的 `exp` 函数，因此链接时，会将 **libm.a** 中需要的代码**“拷贝”**到最终的可执行文件 **main** 中。由于最终生成的可执行文件中已经包含了 `exp` 相关的二进制代码，因此这个可执行文件在一个没有 **libm.a** 的 Linux 系统中也能正常运行

![image-20240613124723322](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448748.png) 

### 动态库链接

==**什么是动态库？**==
动态库和静态库类似，但是它并不在链接时将需要的二进制代码都“拷贝”到可执行文件中，而是仅仅“拷贝”一些**重定位和符号表**信息，这些信息可以在**程序运行时**完成真正的链接过程。Linux中通常以 **.so（shared object）**作为后缀

==**为什么要有动态库？**==

1. **在静态链接时 当多份可执行文件链接同一个重定位文件时，均拥有一份重定位文件的副本，对磁盘以及内存产生极大浪费**
2. **静态库文件发生变更时，需要重新编译和链接**

==**Linux实现动态共享库方式？**==

1. 每个文件系统中，每个库只有**唯一**的一个 **.so** 文件 使用这个库的程序可以**共享 .so** 文件的代码和只读数据 而非将 **.so **文件复制一份
2. 可执行文件启动时，先将控制权交给**动态链接器**，动态链接器会**将可执行文件依赖的共享库文件加载进内存**（也可延迟加载），等共享库加载完毕后将控制权交给可执行文件的入口函数，开始运行 

在静态链接时，可执行文件中的段是由每个可重定位文件的段**拼接**而来的。在动态链接时，共享库在**运行时进行加载**，加载时 Linux 系统会按照**内存映射文件的形式将共享库文件整个映射到内存中堆栈之间的某个起始地址（一般为0x40000000**），并不会进行段的拆分和合并工作，示意图如下。

![img](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448749.jpeg)

### 静态链接与动态链接的区别

| 区别                    | 静态链接                                                     | 动态链接                                                     |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 可执行文件大小不一样 | 将需要用到的**代码**从二进制文件中“拷贝”了一份               | 仅仅是复制了一些**重定位和符号表**信息                       |
| 2. 占用磁盘大小不一样   | 如果有多个可执行文件，那么静态库中的同一个函数的代码就会被**复制多份** | 动态库**只有一份**                                           |
| 3. 扩展性与兼容性不一样 | 如果静态库中某个函数的实现变了，那么可执行文件必须**重新编译**(更具体点是链接) | 只需要更新动态库本身即可，不需要重新编译可执行文件           |
| 4. 依赖不一样           | 静态链接的可执行文件不需要依赖其他的内容即可运行             | 动态链接的可执行文件必须**依赖动态库的存在**                 |
| 5. 复杂性不一样         | easy                                                         | 运行时确定地址、多个进程如何共享、动态库版本管理...          |
| 6. 加载速度不一样       | 静态库在链接时就和可执行文件在一块了，故静态链接更快         | 选择静态库还是动态库是**时间和空间**的考量，但是通常来说，牺牲这点性能来换取程序在空间上的节省和部署的灵活性时值得的。再加上**局部性原理**，牺牲的性能并不多 |

***

# 服务器项目复盘

1. main()中开启两个进程：**网络服务器进程 + 日志服务器进程 **         
2. 网络服务器中开启**子进程**客户端处理进程，将**`accept`**的连接套接字全部发送给客户端处理进程处理后续的I/O （Reactor）
3. 其他进程与日志服务器进程通信采用**本地套接字**方式
4. Linux下的后台开发，先把**进程关系**理清楚(进程关系图)，单进程多线程当然可以完成功能实现，但是进程是操作系统资源分配的==最小单位==（即若进程被挂起，则进程下的所有线程都不再具有系统资源的操作权限），故要充分利用系统资源，最好的形式是**多进程多线程**。即将一个整体功能分散到多个进程中，实现==资源利用率最大化==，否则多线程在一个进程内竞争，资源利用率低！ （线程是操作系统调度的基本单位，调度程序以线程为基本单位进行时间片分配和切换，进程本身并不是直接被调度执行的实体）

![image-20240605214002482](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745026.png)                                                              



## 模板类---泛型编程 + C++11新特性 + 多态

**==通用的==可调用对象类，用于生成==任意==函数指针与参数数量的==可调用对象== **

1.  定义可调用对象基类（为了隔绝模板的传染性，在其他类中的可调用对象均声明为基类指针类型）

   ```c++
   class CFunctionBase 
   {
   public:
       virtual ~CFunctionBase() {}
       virtual int operator()() { return -1; }              // 表示没有延迟参数，即实例化一个可调用对象后其所有参数已经确定
       virtual int operator()(CSocketBase*) { return -1; }  // 表示有一个延迟参数，即调用一个可调用对象时会传参
       virtual int operator()(CSocketBase*, const Buffer&) { return -1; } // 表示有两个延迟参数
       // ... 可重载n个参数不同的函数调用运算符
   };
   ```

2. 定义可调用对象模版类，继承自基类，支持传任意函数指针与参数(C++11 **`std::bind std::forward std::function`** )

   ```C++
   template <typename _FUNCTION_, typename... _ARGS_> // 无延迟参数可调用对象模版类
   class CFunction : public CFunctionBase 
   {
   public:
       CFunction(_FUNCTION_ func, _ARGS_... args) // 基于传入的参数(函数指针、函数参数)实例化模版
           :m_binder(std::bind(std::forward<_FUNCTION_>(func), std::forward<_ARGS_>(args)...))
       {}
       virtual ~CFunction() {}
       virtual int operator()() { 
           return m_binder(); 
       }
       std::function<int()> m_binder; // 可调用对象
   };
   
   template<typename _FUNCTION_, typename... _ARGS_> // 单个延迟参数可调用对象模版类
   class CConnectedFunction :public CFunctionBase
   {
   public:
       CConnectedFunction(_FUNCTION_ func, _ARGS_... args)
           :m_binder(std::bind(std::forward<_FUNCTION_>(func), std::forward<_ARGS_>(args)...))
       {}
       virtual ~CConnectedFunction() {}
       virtual int operator()(CSocketBase* pClient) {
           return m_binder(pClient); // 实例化模板时传入占位符来实现支持延迟参数
       }
       std::function<int(CSocketBase*)> m_binder;
   };
   
   template<typename _FUNCTION_, typename... _ARGS_> // 两个延迟参数可调用对象模版类
   class CReceivedFunction :public CFunctionBase
   {
   public:
       CReceivedFunction(_FUNCTION_ func, _ARGS_... args)
           :m_binder(std::bind(std::forward<_FUNCTION_>(func), std::forward<_ARGS_>(args)...))
       {}
       virtual ~CReceivedFunction() {}
       virtual int operator()(CSocketBase* pClient, const Buffer& data) {
           return m_binder(pClient, data);
       }
       std::function<int(CSocketBase*, const Buffer&)> m_binder;
   };
   ```

3. 在要使用可调用对象的类中定义**可调用对象成员变量**与**初始化可调用对象的成员函数 **(**eg: 进程类、线程类、客户端处理接口类**)

   ```C++
   class CUseFunc // 要使用可调用对象的类
   {
   public:
       template<typename _FUNCTION_, typename... _ARGS_>
       int SetFunc(_FUNCTION_ func, _ARGS_... args) { // 初始化可调用对象的成员函数
           m_func = new CFunction<_FUNCTION_, _ARGS_...>(func, args); // 无延迟参数 多态(基类指针指向派生类对象)
           m_func = std::make_shared<CFunction<_FUNCTION_, _ARGS_...>>(func, args);
           m_func = std::make_shared<CFunction<_FUNCTION_, _ARGS_...>>(func, args...); // 智能指针封装
           return 0;
       }
       template<typename _FUNCTION_, typename... _ARGS_>
       int SetFunc1(_FUNCTION_ func, _ARGS_... args) {
           m_func1 = new CConnectedFunction<_FUNCTION_, _ARGS_...>(func, args...); // 一个延迟参数
           return 0;
       }
       template<typename _FUNCTION_, typename... _ARGS_>
       int SetFunc2(_FUNCTION_ func, _ARGS_... args) {
           m_func1 = new CReceivedFunction<_FUNCTION_, _ARGS_...>(func, args...); // 两个延迟参数
           return 0;
       }
       int func3(CSocketBase* sock, const Buffer&){} // 非静态成员函数
   private:
       CFunctionBase* m_func; // 可调用对象指针的成员变量
       std::shared_ptr<CFunction> m_func; // 智能指针封装
       CFunctionBase* m_func1;  
       CFunctionBase* m_func2;
       CFUnctionBase* m_func3;
   };
   ```

4.  初始化可调用对象（模版函数、**`std::placeholders`**）==注意==如果函数调用方式是**`_thiscall`**(类的非静态成员函数)，第一个参数要传**`this`**

   ```C++
   int func() // 函数指针 注意函数签名中有多少参数都没关系，关键是有没有延迟参数，即可调用对象生成后，在调用时还需要传入参数
   {
       printf("this is func, without delay param!\n");
   }
   int func1(CSocketBase* sock) // 函数指针
   {
       printf("this is func1, with a delay param CSocketBase*!\n");
   }
   int func2(CSocketBase* sock, const Buffer& data) // 函数指针
   {
       printf("this is func2, with two delay param!\n");
   }
   
   int main()
   {
       CUseFunc useFunc;
       useFunc.SetFunc(func); // 初始化可调用对象
       useFunc.SetFunc1(func1, std::placeholders::_1); // 初始化有一个延迟参数的可调用对象 一个占位符
       useFunc.SetFunc2(func2, std::placeholders::_1, std::placeholders::_2); // 初始化有两个延迟参数的可调用对象 两个占位符
       useFunc.SetFunc2(func3, this, std::placeholders::_1, std::placeholders::_2); // 封装类的非静态成员函数，需要传this
       
   }
   ```

5.  调用

   ```C++
   (*m_func)(); // 调用
   CSocketBase* para1;
   const Buffer para2;
   (*m_func1)(para1); // 调用
   (*m_func2)(para1, para2); // 调用
   (*m_func3)(para1, para2); // 调用
   ```

## 进程类的设计(CProcess)---进程间通信

- 创建子进程(`CreateSubProcess()`)，在子进程中执行线程入口函数

- 进程入口函数采用上述**泛型编程**思想以支持**任意**函数指针与参数，在此不赘述

- 由于网络服务器进程需要将其**`accept`**到的连接套接字发送给其子进程(客户端处理进程)，我们使用`socketpair()`

  ![image-20240605221512678](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745027.png) 

  ```C++
  int pipes[2]; // 存储socketpair()创建的两个fd 本项目中，pipes[0]用于子进程读，pipes[1]用于父进程写(如果要父子进程互传，则需要两个pipes[2])
  socketpair(AF_LOCAL, SOCK_STREAM, 0, pipes); // 创建一对套接字放在pipes中 注意必须在fork()前创建，这样父子进程就都拥有这对套接字
  
  //网络服务器进程(主)将connect()上来的网络用户连接套接字及其地址传给客户端处理进程(子)
  int SendSocket(int fd, const sockaddr_in* addrin) {
          struct msghdr msg; // 用于在套接字间传递消息的元数据结构。它允许发送和接收消息时，同时携带多个缓冲区的数据、目标地址、控制信息等
          iovec iov; // 用于描述一块连续内存区域的信息,指定数据的缓冲区和长度
          char buf[20] = ""; // 初始化一个大小为 20 字节的缓冲区 buf，用于存放地址信息
          bzero(&msg, sizeof(msg));
          memcpy(buf, addrin, sizeof(sockaddr_in));
          iov.iov_base = buf; // 设置iov结构体成员
          iov.iov_len = sizeof(buf);
          msg.msg_iov = &iov; // 将iov结构体设置到msghdr结构体中
          msg.msg_iovlen = 1;
  
          cmsghdr* cmsg = (cmsghdr*)calloc(1, CMSG_LEN(sizeof(int))); // 用于在套接字间传递控制信息的结构体，可以传递fd等控制信息
          if (cmsg == NULL)return -1;
          cmsg->cmsg_len = CMSG_LEN(sizeof(int));
          cmsg->cmsg_level = SOL_SOCKET; // 控制信息的级别
          cmsg->cmsg_type = SCM_RIGHTS; // 控制信息的类型，这里表示传递fd
          *(int*)CMSG_DATA(cmsg) = fd; // 控制信息的数据部分
          msg.msg_control = cmsg; // 将cmsghdr设置到msghdr结构体中
          msg.msg_controllen = cmsg->cmsg_len;
  		// sendmsg()系统调用，用于发送消息到指定的套接字 可以在一个系统调用中发送多个缓冲区的数据
          ssize_t ret = sendmsg(pipes[1], &msg, 0); // 将fd和地址信息一起发给子进程，pipes[1]用于主进程写，子进程中需关闭这端(pipes[1]=0)
          free(cmsg);
          return 0;
      }
  // 客户端处理进程(子)接收网络服务器进程(主)发过来的网络用户连接套接字及其地址
  int RecvSocket(int& fd, sockaddr_in* addrin) 
      {
          msghdr msg; // 消息结构体
          iovec iov;
          char buf[20] = "";
          bzero(&msg, sizeof(msg));
          iov.iov_base = buf;
          iov.iov_len = sizeof(buf);
          msg.msg_iov = &iov;
          msg.msg_iovlen = 1;
  
          cmsghdr* cmsg = (cmsghdr*)calloc(1, CMSG_LEN(sizeof(int)));
          if (cmsg == NULL)return -1;
          cmsg->cmsg_len = CMSG_LEN(sizeof(int));
          cmsg->cmsg_level = SOL_SOCKET;
          cmsg->cmsg_type = SCM_RIGHTS;
          msg.msg_control = cmsg;
          msg.msg_controllen = CMSG_LEN(sizeof(int));
      	// recvmsg()系统调用，用于从指定的套接字接收消息。它可以在一个系统调用中接收多个缓冲区的数据
          ssize_t ret = recvmsg(pipes[0], &msg, 0); // 接收fd和地址信息，pipes[0]用于子进程读，主进程中需关闭这端(pipes[0]=0)
          memcpy(addrin, buf, sizeof(sockaddr_in)); // 将接收到地址信息拷贝给出参2，即这样子进程就拿到了地址信息
          fd = *(int*)CMSG_DATA(cmsg); // 将接收到的fd拷贝给出参1，这样子进程就拿到了连接套接字
          free(cmsg);
          return 0;
      }
  ```

- [进程间通信的方式](https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93)：管道、消息队列、共享内存、信号量、信号、Socket

- [守护进程](https://www.bilibili.com/video/BV1EG4y1d7rp/?spm_id_from=333.337.search-card.all.click&vd_source=62aa2836d3b2cff426a89393eeb8efd4)：是在后台运行的一种特殊类型的进程，通常在操作系统启动时启动，并且在操作系统关闭时关闭。它们通常在没有用户交互的情况下在后台运行，并且通常不受终端控制。

  ```C++
  static int SwitchDeamon() {   // 将进程转为守护状态
          pid_t ret = fork();   // 1. 创建子进程并退出父进程
          if (ret > 0) exit(0); 
          // 子进程内容如下
          ret = setsid(); // 2.创建新会话，让子进程成为会话首进程和新的进程组组长，实现与之前的终端、会话和控制端脱离
          ret = fork(); // 3.创建孙进程并结束子进程
          if (ret > 0) exit(0);
          // 孙进程内容如下，进入守护状态
          for (int i = 0; i < 3; i++) close(i); // 4.关闭标准输入输出和错误
          umask(0); // 5.清除文件创建屏蔽字
          signal(SIGCHLD, SIG_IGN); // 6.忽略子进程的退出信号 表示守护进程对其子进程结束不关心，由内核回收
          return 0;
      }
  ```

## epoll的封装(CEpoll)

- [epoll](https://zhuanlan.zhihu.com/p/367591714) :用到的==**结构体**==

  - **`epoll_event`**

  ![image-20240606175331414](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745028.png) 

  其中，**`events`**可以是以下几个宏的集合(bitmap，**按位|**可以增加集合属性，**按位&**可以判断集合属性)：

  1. EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；
  2. EPOLLOUT：表示对应的文件描述符可以写；
  3. EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
  4. EPOLLERR：表示对应的文件描述符发生错误；
  5. EPOLLHUP：表示对应的文件描述符被挂断；
  6. EPOLLET ：将 EPOLL 设为边缘触发(Edge Trigger)模式，这是相对于水平触发(Level Trigger)来说的。
  7. EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里

  - **`event_poll`**

    ```C++
    //struct eventpoll 的定义
    // file：fs/eventpoll.c
    struct eventpoll {
    
        //sys_epoll_wait用到的等待队列
        wait_queue_head_t wq;
    
        //接收就绪的描述符都会放到这里
        struct list_head rdllist;
    
        //每个epoll对象中都有一颗红黑树
        struct rb_root rbr;
    
        ......
    }
    ```

  1. **wq**:  等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。
  2. **rbr：** 红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用的就是红黑树。通过红黑树来管理用户主进程accept添加进来的所有 socket 连接。
  3. **rdllist：** 就绪的描述符链表。当有连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历红黑树的所有节点了。

- epoll的三个==**接口函数**==

  - **`epoll_create`**

    ```C++
    int epoll_create(int size);
    ```

    1. **功能：**该函数生成一个 epoll 专用的文件描述符
    2. **参数size:** 用来告诉内核这个监听的数目一共有多大，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。自从 linux 2.6.8 之后，size 参数是被忽略的，也就是说可以填只有大于 0 的任意值
    3. **返回值：**如果成功，返回epoll 专用的文件描述符，否者失败，返回-1

    ```C++
    int epoll_create1(int flags);
    ```

    1. **功能：**该函数生成一个 epoll 专用的文件描述符。
    2. **参数flags:** 允许传递额外的选项来控制 epoll 实例的行为,目前支持的选项有**EPOLL_CLOEXEC**。告诉操作系统在创建 epoll 实例时将其设置为 close-on-exec（CLOEXEC）模式。在 CLOEXEC 模式下，当一个进程调用 fork() 创建子进程或调用 exec() 执行一个新程序时，内核会**自动关闭** epoll 实例，以防止在子进程或新程序**中泄漏 epoll 文件描述符**。这是一种**安全措施**，确保 epoll 文件描述符不会在不应该的地方被误用
    3. **返回值：**如果成功，返回epoll 专用的文件描述符，否者失败，返回-1

  - **`epoll_ctl`**

    ```c++
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
    ```

    1. **功能：**epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型

    2. **参数op:** 表示动作，用三个宏来表示：

       EPOLL_CTL_ADD：注册新的 fd 到 epfd 中

       EPOLL_CTL_MOD：修改已经注册的fd的监听事件

       EPOLL_CTL_DEL：从 epfd 中删除一个 fd

    3. **参数fd:** 需要监听的文件描述符

    4. **参数event:** 告诉内核要监听什么**事件及用户自定义的传参**，epoll_event 结构体指针，参考上文

    5. **返回值：**0表示成功，-1表示失败

  -  **`epoll_wait`**

    ```C++
    int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
    ```

    1. **功能：**等待事件的产生，收集在 epoll 监控的事件中已经发生的事件，类似于 select() 调用
    2. **参数epfd:** epoll 专用的文件描述符，epoll_create()的返回值
    3. **参数events:** 分配好的 epoll_event 结构体数组，epoll 将会把发生的事件赋值到events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）
    4. **参数maxevents:** maxevents 告之内核这个 events 有多少个
    5. **参数timeout:** 超时时间，单位为毫秒，为 -1 时，函数为阻塞
    6. **返回值：** 成功--->表示返回需要处理事件的数目 、超时--->返回0、  失败--->返回-1

- **EpollData**：将联合体 **epoll_data_t** 封装成类，方便赋值

- **CEpoll**: 封装的 epoll 类，支持创建、等待事件、注册事件、修改事件、删除已注册的事件以及关闭**epoll**等操作

  ```C++
  int m_epoll; // 类中唯一成员变量 epoll 专用的文件描述符
  using EPEvents = std::vector<epoll_event>; // 创建epoll_event动态数组的别名 
  ```

  ```C++
  // 禁止进行复制构造和赋值运算，因为epoll本质是内核对象，用户态无法复制构造或赋值 构造完CEpoll实例后，只能通过Create()接口创建
  CEpoll(const CEpoll&) = delete; // 不会实现 没必要写参数名
  CEpoll& operator=(const CEpoll&) = delete; // 不会实现，没必要写参数名
  
  // 创建epoll专用fd(树根)
  int Create(unsigned count); // 基于 epoll_creat1
  
  // 等待事件的发生 <0->发生错误 =0->没有事情发生 >0->成功拿到事件 para1:出参，用来接收epoll返回的发生的事件 para2:超时时间
  ssize_t waitEvents(EPEvents& events, int timeout = 10); // 基于 epoll_wait
  
  // 注册fd para1:加入epoll监控的fd para2：自定义数据，一般用来传递额外参数 para3:需要监听的事件类型，默认为可读
  int Add(int fd, const EpollData& data = EpollData((void*)0), uint32_t events = EPOLLIN);  // 这三个均基于 epoll_ctl
  // 修改已经注册的fd的监听事件
  int Modify(int fd, uint32_t events, const EpollData& data = EpollData((void*)0));
  // 删除已经注册的fd
  int Del(int fd)；
      
  void Close(); // 关闭epoll 
  ```

## 套接字的封装(CSocket)---支持本地、网络、UDP、TCP、客户端、服务器所使用的套接字

- 套接字属性：**位掩码** + 枚举类型 

  ```C++
  enum SockAttr { // 套接字属性
  	SOCK_ISSERVER = 1,  // 是否为服务器，0-客户端 1-服务器				  00001
  	SOCK_ISNOBLOCK = 2, // 是否阻塞	    0-阻塞   1-非阻塞				00010
  	SOCK_ISUDP = 4,     // 是否为UDP，   0-tcp   1-udp				   00100
  	SOCK_ISIP = 8,      // 是否为IP协议  0-本地套接字 1-IP协议(网络套接字)  01000   
  	SOCK_ISREUSE = 16   // 是否重用地址  0-不重用 1-重用                  10000 
      // 即使端口处于 TIME_WAIT 状态，也可以立即在该端口上重新绑定一个新套接字 
      // 对于需要频繁启动和停止服务器程序的开发过程特别有用，因为可以避免 "Address already in use" 错误
  }; // 如果这时候套接字属性为attr=11111(二进制)， 通过判断按位与(&)就知道是哪些属性的组合
  ```

- 套接字参数类:**CSockParam**

  ```C++
  // 成员变量
  sockaddr_in addr_in; // 网络套接字地址结构体
  sockaddr_un addr_un; // 本地套接字地址结构体
  Buffer ip; // ip
  short port; // 端口
  int attr; // 参考SockAttr 套接字属性
  ```

- 套接字抽象类：**CSocketBase**

  封装套接字抽象接口类，抽象出 Init()、Link()、Recv()、Send()、Close()五个接口，将**C/S通信流程抽象**，屏蔽了网络套接字与本地套接字的区别

  ![](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745029.png) 

  ```C++
  // 成员变量
  protected: // 只让子类继承 不让外部访问 故为protected
  	int m_socket; // 套接字fd，默认-1（在服务器端是监听套接字）
  	int m_status; // 套接字当前状态，0-初始化未完成 1-初始化完成 2-连接完成 3-已关闭
  	CSockParam m_param; // 初始化套接字参数
  // 成员方法
  // 1.Init():服务器-套接字创建、bind、listen 客户端-套接字创建
  virtual int Init(const CSockParam& param) = 0; // 根据输入参数来创建本地、网络、客户端
  // 2.Link():服务器-accept 客户端-connect 对于udp，这里可以忽略
  // 这里的参数，对于服务器来说，connect()会返回一个连接套接字，在Link中会配置这个套接字，需要用二级指针传出去，抽象类没有实例，不能引用传参
  virtual int Link(CSocketBase** pClient = NULL) = 0; // 对于客户端不需要这个参数，故默认为 NULL
  // 3.Send()
  virtual int Send(const Buffer& data) = 0;
  // 4.Recv()
  virtual int Recv(Buffer& data) = 0;
  // 5.Close()
  virtual int Close();
  ```

- 通用套接字类：**CSocket :public CSocketBase**

  ```C++
  // 成员方法
  virtual int Init(const CSockParam& param){
      // 1.创建socket
      int type = (m_param.attr & SOCK_ISUDP) ? SOCK_DGRAM : SOCK_STREAM; // 若参数属性为UDP，则设置对应的类型
      if (param.attr & SOCK_ISIP) // 如果是IP协议
          m_socket = socket(PF_INET, type, 0);  // 创建网络套接字
      else
          m_socket = socket(PF_LOCAL, type, 0); // 创建本地套接字
      // 2.判断是否为服务器，服务器的话还要 bind listen
      if (param.attr & SOCK_ISIP) // 如果是网络套接字，那就绑定网络套接字的地址结构体
     		bind(m_socket, m_param.addrin(), sizeof(sockaddr_in)); // para1:要绑定的套接字fd para2:要绑定的地址和端口信息(一个地址结构体*)
      else
          bind(m_socket, m_param.addrun(), sizeof(sockaddr_un)); // para1:要绑定的套接字fd para2:要绑定的地址和端口信息(一个地址结构体*)
      listen(m_socket, 32);
      
  virtual int Link(CSocketBase** pClient = NULL){ // 外面如果是服务器调这个，给一个空的CSocketBase**过来，accept得到的连接套接字就能传出去
      // 1.如果是服务器，accept
      CSockParam param; // 默认 客户端、阻塞、tcp、 本地 用来给accept得到的连接套接字初始化
      if (m_param.attr & SOCK_ISIP) { // 网络套接字
          param.attr |= SOCK_ISIP;
          len = sizeof(sockaddr_in);
          fd = accept(m_socket, param.addrin(), &len); // 返回通信套接字 同时将请求连接的客户端的地址信息填到param中
      }
      else { // 本地套接字
          len = sizeof(sockaddr_un);
          fd = accept(m_socket, param.addrun(), &len); // 返回通信套接字 同时将请求连接的客户端的地址信息填到param中
      }
      *pClient = new CSocket(fd); // 配置连接套接字
      (*pClient)->Init(param); // 连接套接字初始化 由于是二级指针传参，会作为出参返回 服务器那边就可以得到一个设置好的与客户端通信的连接套接字对象
      // 2.如果是客户端，connect
      if (m_param.attr & SOCK_ISIP) // 网络套接字
          connect(m_socket, m_param.addrin(), sizeof(sockaddr_in)); 
      else // 本地套接字
          connect(m_socket, m_param.addrun(), sizeof(sockaddr_un));
  }
      
  virtual int Send(const Buffer& data) { // 这里的参数是指定要发送的数据 即发送缓冲区
      ssize_t index = 0; // 已发送的数据
      while (index < (ssize_t)data.size()) {
          ssize_t len = write(m_socket, (char*)data + index, data.size() - index); // 返回写入buffer的长度
          index += len;
      }
  }
      
  virtual int Recv(Buffer& data) { // 出参，读入的数据通过参数返回 这里的参数用来读数据 即接收缓冲区
      data.resize(1024 * 1024); // 给缓冲区大小
      ssize_t len = read(m_socket, data, data.size());
      if (len > 0) { // 读了len个字节大小
          data.resize(len); // 通过出参只返回读入的数据
          return (int)len; // 返回收到的数据大小
      }
      data.clear();
      if (len < 0) {
          if (errno == EINTR || errno == EAGAIN) { // read()返回是因为被中断，或非阻塞(即轮循EAGAIN 表示当前没有数据可读，内核buffer没就绪会直接返回)，不能算接收失败
              data.clear();
              return 0; // 没有收到数据 但不算失败
          }
      }
  }
      
  virtual int Close();
  ```

## 线程的封装(CThread)

封装线程类，Start()、Pause()、Stop()、SetThreadFunc() 等接口

```c++
// 成员变量
CFunctionBase* m_function; // 线程函数指针
pthread_t m_thread; // 线程id
bool m_bpaused; // true-暂停 false-运行中
static std::map<pthread_t, CThread*> m_mapThread; // 线程id与线程对象指针的hash_map 属于整个类的所有实例(静态成员)
```

线程函数采用前文**泛型编程**思想以支持**任意**函数指针与参数，在此不赘述

注意还是要通过一个静态线程入口函数+this指针给**`pthread_create`**传参，原因见前文<<线程创建>>

```c++
// 禁止进行复制构造和赋值运算，因为thread本质是内核对象，用户态无法复制构造或赋值
CThread(const CThread&) = delete; //  不会实现 没必要写形参名
CThread operator=(const CThread&) = delete;

int Start() {
    pthread_attr_t attr; // 线程属性对象。线程属性对象包含创建线程时可以指定的各种属性，如堆栈大小、调度策略、继承调度属性等
    pthread_attr_init(&attr); // 初始化线程属性对象
    // 设置线程为 joinable 状态意味着线程在结束时不会自动释放资源，需要调用 pthread_join 来清理资源
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE); 
    // 创建线程, para1：出参，存放新线程id para2:线程属性对象 para3:新线程执行的函数(要求全局可见) para4:传递给新线程函数的参数 
    ret = pthread_create(&m_thread, &attr, &CThread::ThreadEntry, this); 
    m_mapThread[m_thread] = this; // hash_map保存线程id和当前线程类对象的映射关系
    ret = pthread_attr_destroy(&attr); // 销毁线程属性对象，释放相关资源
    return 0;
}

int Pause() { // 暂停/恢复
    if (m_bpaused) { // 如果当前处于暂停，修改状态标志为运行
        m_bpaused = false; // 这样子暂停那边的信号处理函数循环就会跳出，不再暂停
        return 0;
    }
    m_bpaused = true; // 当前在运行中，修改状态标志为暂停
    int ret = pthread_kill(m_thread, SIGUSR1); // 发送暂停信号SIGUSR1
    return 0;
}

int Stop() {
    if (m_thread != 0) { // 线程id为0说明不用再停止
        pthread_t thread = m_thread;
        m_thread = 0;
        timespec ts; // 设置等待时间 创建一个 timespec 结构体
        ts.tv_sec = 0; // 秒=0
        ts.tv_nsec = 100 * 1000000; // 100ms 纳秒=10*1000000，即100ms
        // 因为下面要在其他某个线程中尝试等待thread是否结束，故线程创建时属性为：PTHREAD_CREATE_JOINABLE
        int ret = pthread_timedjoin_np(thread, NULL, &ts); // 尝试在 ts 时间内等待线程结束
        if (ret == ETIMEDOUT) { // 在指定的等待时间内，线程没有结束
            pthread_detach(thread); // 将线程分离，以确保当线程最终结束时其资源会被自动释放
            pthread_kill(thread, SIGUSR2); // 向线程发送 SIGUSR2 信号 
        }
    }
    return 0;
}

// 信号处理函数，para1:接收到的信号编号 para2:信号的附加信息 para3:信号处理时的上下文信息
static void Sigaction(int signo, siginfo_t* info, void* context) { 
    if (signo == SIGUSR1) { // 暂停
        pthread_t thread = pthread_self(); // 获取当前的线程id
        auto it = m_mapThread.find(thread); // hash_map中查找线程id及其对应的线程类实例对象
        if (it != m_mapThread.end()) // 找到
            if (it->second) // 线程id对应的线程类对象
                while (it->second->m_bpaused) // 当前线程处于暂停状态就继续暂停，暂停状态再调用Pause()会将m_bpaused置false，就恢复了
                    usleep(1000); // 休眠1ms后继续循环
    else if (signo == SIGUSR2) // 线程退出
        pthread_exit(NULL);
}
```

## 线程池的封装(CThreadPool)

封装线程池类，Start()、Close()、AddTask()、TaskDispatch() 等接口

任务分发机制：**epoll + 本地套接字通信** 避免了线程池中多线程竞争任务带来的互斥同步问题，无需引入需要加锁的任务队列(我是线程池类中定义了epoll成员)

```c++
// 成员变量
Buffer m_path; // 本地套接字地址(即 UNIX套接字文件[.sock]) 线程池类的构造函数中会根据当前时间初始化一个.sock 文件名 bind()时会生成对应的.sock文件
CSocketBase* m_server; // 线程池本地监听套接字
CEpoll m_epoll; // epoll监听I/O事件(其实就是有没有给线程池分配任务)
std::vector<CThread*> m_threads; // 线程池中的线程指针vector
```

```c++
// 成员方法

// 1.创建并初始化本地监听套接字对象 2.创建epoll树根(eventpoll结构 wq-等待队列 rbr-红黑树 rdllist-就绪的fd链表)
// 3 监听套接字挂树 4.创建线程并指定线程函数TaskDispatch() 5.启动线程
int Start(unsigned count) { // 线程池中线程的个数需要在线程池构造时就指定
    m_server = new CSocket(); // 本地监听套接字
    ret = m_server->Init(CSockParam(m_path, SOCK_ISSERVER)); // 监听套接字初始化 socket()->bind()->listen()
    ret = m_epoll.Create(count); // 创建epoll树根
    // *m_server->取到套接字对象->Add()第一个参数会有一个int的隐式类型转换，拿到的就是fd(sock)
    ret = m_epoll.Add(*m_server, EpollData((void*)m_server)); // 监听套接字挂树
    m_threads.resize(count); // 根据参数修改线程vector数量
    for (unsigned i = 0; i < count; i++) {
        m_threads[i] = new CThread(&CThreadPool::TaskDispatch, this); // 创建线程时指定线程函数，传递this指针
        ret = m_threads[i]->Start(); // 启动线程
    }
    return 0;
}

// 1.关闭epoll 2.关闭监听套接字 3.关闭线程池中所有线程 4.删除文件路径(本地套接字通信中服务器ip其实就是.sock文件)
void Close() {
    m_epoll.Close();
    if (m_server) {
        CSocketBase* p = m_server;
        m_server = NULL;
        delete p;
    }
    for (auto thread : m_threads)
    {
        if (thread) delete thread;
    }
    m_threads.clear();
    unlink(m_path);
}

// 支持任意参数的任务函数
template<typename _FUNCTION_, typename... _ARGS_>
// 主进程中调用该函数: 1.建立one thread one client 的连接(与线程池) 2.通过本地套接字将任务发送给线程池
int AddTask(_FUNCTION_ func, _ARGS_... args) {
    static thread_local CSocket client; // 每个线程拥有一个本地套接字对象(线程作为客户端)
    // 静态的但每个线程(static thread_local)调这个函数都会构造一个新的 client 即一个线程对应一个客户端
    ret = client.Init(CSockParam(m_path, 0)); // 初始化客户端套接字 此时服务器的地址已经在m_path中了
    ret = client.Link(); // 客户端的Link() 即 connect() 建立客户端(想要给线程池添加任务的进程/线程)与线程池的连接
    CFunctionBase* base = new CFunction<_FUNCTION_, _ARGS_...>(func, args...); // 任务函数
    Buffer data(sizeof(base));
    memcpy(data, &base, sizeof(base));
    ret = client.Send(data); // 将任务函数对象指针发给线程池的监听套接字
    return 0;
}

// 共享epoll树根 -> 一起wait(都在epoll的等待队列中) -> 谁抢到(竞争到)事件(m_server上的读->连接客户端 pClient上的读->执行任务函数)谁就干(被唤醒)
int TaskDispatch() {
    EPEvents events; // epoll_event 结构体（{event, data}event->希望监听的事件 data->自定义参数）的vector 用来接收epoll_wait()返回
    //esize=发生事件数量，events=出参存储发生的事件(就绪链表)
    ssize_t esize = m_epoll.waitEvents(events); 
    if (esize > 0) {
        for (ssize_t i = 0; i < esize; i++) {
            if (events[i].events & EPOLLIN) { // 读事件
                CSocketBase* pClient = NULL;
                if (events[i].data.ptr == m_server) { // 监听套接字上的读事件，说明是Addtask()里面的Link()
                    ret = m_server->Link(&pClient); // 通过二级指针返回accept()到的连接套接字
                    ret = m_epoll.Add(*pClient, EpollData((void*)pClient)); // 连接套接字挂树(.Add()para3默认为可读事件)
                }
                else { // 连接套接字上的读事件，即有任务请求
                    pClient = (CSocketBase*)events[i].data.ptr;
                    if (pClient) {
                        CFunctionBase* base = NULL;
                        Buffer data(sizeof(base));
                        ret = pClient->Recv(data);
                        memcpy(&base, (char*)data, sizeof(base)); // 得到任务函数
                        if (base != NULL) {
                            (*base)(); // 调用任务函数 base->函数对象指针 *base->可调用对象
                            delete base;
                        }
                    }
                }
            }
    return 0;
}
```

## 日志服务器

**功能**：接收客户端进程、客户端处理进程的**连接请求与写日志**请求(基于**本地套接字**)

```C++
// 成员变量
CThread m_thread; // 日志服务器的线程 只有一个线程负责处理连接和写日志，故不用考虑线程间的互斥同步
CSocketBase* m_server; // 日志服务器的监听套接字
CEpoll m_epoll; // epoll 监听I/O事件
Buffer m_path; // 日志文件存放路径
FILE* m_file; // 日志文件指针 
```

```c++
// 成员方法

// 1.线程函数 主要是执行 epoll_wait 同时对其返回的就绪IO事件进行处理(监听套接字->处理连接、连接套接字->写日志)
int ThreadFunc() { 
    EPEvents events; // epoll_event结构体的动态数组 用来接收epoll_wait()返回的发生事件
    std::map<int, CSocketBase*> mapClients; // 本地通信对象的套接字及对象指针的map
    while (m_thread.isValid() && (m_epoll != -1) && (m_server != NULL)) { // 日志服务器线程OK epoll OK 本地监听套接字对象OK
        ssize_t ret = m_epoll.waitEvents(events, 1000); // 等待事件发生，ret=数量，events=出参存储发生的事件(epoll_event)，超时时间=1ms
        for (; i < ret; i++) {
            if (events[i].events & EPOLLIN) { // 可读
                if (events[i].data.ptr == m_server) { // 监听套接字可读 则处理客户端的连接
                    CSocketBase* pClient = NULL; // 通信套接字对象指针
                    int r = m_server->Link(&pClient); // 通过二级指针返回连接后的通信套接字对象指针
                    // 连接套接字挂树(加入监听并注册事件)
                    r = m_epoll.Add(*pClient, EpollData((void*)pClient), EPOLLIN | EPOLLERR); 
                    mapClients[*pClient] = pClient; // 更新map
                }
                else { // 连接套接字可读 则接收并写日志
                    CSocketBase* pClient = (CSocketBase*)events[i].data.ptr; // 拿到发生可读事件的连接套接字对象指针	
                    Buffer data(1024 * 1024);
                    int r = pClient->Recv(data); // 接收
                    WriteLog(data); // 收到数据 写日志
                }
            }
        }
    } 
    // 释放资源 ... 
    return 0;
}

// 2.构造函数
CLoggerServer() :
	m_thread(&CLoggerServer::ThreadFunc, this) // 初始化线程函数
{
    m_server = NULL;
	char curpath[256] = "";
	getcwd(curpath, sizeof(curpath));
	m_path = curpath;
	m_path += "/log/" + GetTimeStr() + ".log"; // 根据当前系统时间初始化日志文件路径
}

// 3.启动日志服务器
int Start() {// 日志服务器的启动：打开日志文件->创建epoll->创建并初始化本地监听套接字->监听套接字挂树->开启线程
    if (access("log", W_OK | R_OK) != 0) { // 
        mkdir("log", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
    } // 检查当前进程对文件 "log" 的读写权限。如果当前进程对 "log" 文件没有读写权限，则创建一个名为 "log" 的目录，并设置相应的权限
    m_file = fopen(m_path, "w+"); // 以读写模式打开日志，如果不存在则创建，如果已经存在则打开文件并清空
    int ret = m_epoll.Create(1); // 创建epoll m_epoll---epoll专用fd
    m_server = new CSocket(); // 创建监听套接字 
    ret = m_server->Init(CSockParam("./log/server.sock", (int)SOCK_ISSERVER | SOCK_ISREUSE)); // 监听套接字初始化
    ret = m_epoll.Add(*m_server, EpollData((void*)m_server), EPOLLIN | EPOLLERR); // 监听套接字挂树
    ret = m_thread.Start(); // 开启线程来使用epoll_wait()等待事件产生
    return 0;
}

// 4.写日志
void WriteLog(const Buffer& data) {
	FILE* pFile = m_file; // 在后续的操作中使用临时指针 pFile，以避免直接操作成员变量
	fwrite((char*)data, 1, data.size(), pFile); // para1:写入数据的起始地址 para2:每次写入数据大小 para3:数据长度 para4:文件指针
	fflush(pFile); // 刷新文件缓冲区，确保数据被立即写入到文件中，而不是暂时存储在缓冲区中等待写入
}

// 5.静态成员方法，用于其他进程or线程通过本地套接字连接日志服务器并发送日志
static void Trace(const LogInfo & info) { // 给其他非日志进程的进程和线程使用的 可以通过类名+作用域符来调用  CLoggerServer::Trace()
    static thread_local CSocket client; // 连接套接字 one thread one connection
    if (client == -1) { // 静态的但每个线程(static thread_local)调这个函数都会构造一个新的 client 即一个线程对应一个客户端
        client.Init(CSockParam("./log/server.sock", 0)); // 指定本地日志服务器套接字路径
        client.Link(); // 客户端Link 即accept
    }
    client.Send(info); // 如果该线程已经和日志服务器建立了连接，直接发送即可
}
```

**日志的设计**：

设定了五个**日志等级**：`LOG_INFO`信息，`LOG_DEBUG`调试，`LOG_WARNING`警告， `LOG_ERROR`错误，`LOG_FATAL`致命

统一了**日志格式**为：源文件名 + 行号 + 日志等级 + 当前时间 + 所在函数 +进程ID + 线程ID +  自定义日志内容

日志类中重载了三个构造函数和`<<`运算符以支持**普通日志**、**流式日志**、**十六进制日志**

结合宏定义能很方便地给日志服务器发送不同类型的日志

**日志类**：

```C++
// 成员变量：
bool bAuto; // 默认是false 流式日志，则为true
Buffer m_buf; // 存储日志信息的字符串缓冲区

// 模版函数 重载输出操作符<< 以支持流式日志
template<typename T> 
LogInfo& operator<<(const T& data) { // 要输出的数据
    std::stringstream stream; // 用于将各种数据转换为字符串
    stream << data; // 利用 << 操作符将 data 写入流中
    m_buf += stream.str().c_str(); // 将流中数据转为字符串，并追加到 m_buf 
    return *this; // 返回对象，以支持链式调用：a << b << c
}

// 构造函数：
// 1.普通日志
LogInfo::LogInfo(
	const char* file, int line, const char* func,
	pid_t pid, pthread_t tid, int level,
	const char* fmt, ...
)
{
	char* buf = NULL;
	bAuto = false;
	// 将固定内容写到日志（文件名、行号、日志级别、时间、进程id、线程id、函数名）
	int count = asprintf(&buf, "%s(%d):[%s][%s]<%d-%d>(%s) ", 
		file, line, sLevel[level],							  
		(char*)CLoggerServer::GetTimeStr(), pid, tid, func);
	
	// 将可变参数列表(即日志内容)写到buf
	va_list ap; 
	va_start(ap, fmt); // 将 ap 初始化为参数列表的起始位 fmt 是日志格式字符串，用于确定可变参数的位置。
	count = vasprintf(&buf, fmt, ap); // 将参数列表中的可变参数格式串化为字符，并将结果保存到 buf 中
	if (count > 0) {
		m_buf += buf;
		free(buf);
	}
	m_buf += "\n";
	va_end(ap); // 结束可变参数列表的访问
}

// 2.流式日志
LogInfo::LogInfo(const char* file, int line, const char* func, pid_t pid, pthread_t tid, int level)
{//自己主动发的 流式的日志 
	bAuto = true; // LogInfo退出作用域时，调用析构函数时 检测m_bool 如果为true 则调用 CLoggerServer::Trace(*this)发送
	// 这里只用写默认格式信息即可，剩下都通过`<<`来生成日志
	char* buf = NULL;
	int count = asprintf(&buf, "%s(%d):[%s][%s]<%d-%d>(%s) ",
		file, line, sLevel[level],
		(char*)CLoggerServer::GetTimeStr(), pid, tid, func);
}

// 3.十六进制格式化日志
略
```

**宏定义**：

```C++
#define TRACEI(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_INFO, __VA_ARGS__))
#define TRACED(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_DEBUG, __VA_ARGS__))
#define TRACEW(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_WARNING, __VA_ARGS__))
#define TRACEE(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_ERROR, __VA_ARGS__))
#define TRACEF(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_FATAL, __VA_ARGS__))

//LOGI<<"hello" << 10 <<"how are you"; // 流失日志在日志对象析构时通过判断 m_bool == true 来调Trace(）
#define LOGI LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_INFO)
#define LOGD LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_DEBUG)
#define LOGW LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_WARNING)
#define LOGE LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_ERROR)
#define LOGF LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_FATAL)

//内存导出
//00 01 02 65……  ; ...a……
#define DUMPI(data, size) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_INFO, data, size))
#define DUMPD(data, size) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_DEBUG, data, size))
#define DUMPW(data, size) CLoggerServer::TraceLogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_WARNING, data, size))
#define DUMPE(data, size) CLoggerServer::TraceLogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_ERROR, data, size))
#define DUMPF(data, size) CLoggerServer::TraceLogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_FATAL, data, size))
```

## 客户端连接服务器(主模块) --- 单Reactor多线程 + 业务接口多态

**功能**：处理各个网络用户的连接请求(`connect`)， 将`accept`上来的连接套接字全部发送给业务子进程处理(客户端处理模块)

**组成**：监听套接字 + epoll + 线程池 + 子进程 + 客户端处理模块的接口 

```c++
// 成员变量
CSocketBase* m_server; // 主模块的监听套接字对象指针
CEpoll m_epoll; // 主模块的epoll
CThreadPool m_pool; // 线程池
CProcess m_process; // 子进程
CBusiness* m_business; // 业务接口 是一个基类指针，故利用继承来实现多态，你初始化时传什么业务接口对象给我，我的子进程就执行什么业务
```

**业务接口**：

```C++
class CBusiness // 客户端处理的接口类
{
public:
	// 1.不做具体的业务实现，但是业务实现需要继承该类
	// 2.接口层最大的作用就是解耦！这里就通过接口层解耦了网络通信(主模块)和业务实现，在主模块中不需要写任何业务实现的具体逻辑
	//   具体的业务实现(客户端处理)通过继承该接口类去做实现
	CBusiness() 
		: m_connectedcallback(NULL), m_recvcallback(NULL) 
	{}
	virtual int BusinessProcess(CProcess* proc) = 0; // 纯虚函数，由派生出的业务处理模块去实现
	template<typename _FUNCTION_, typename... _ARGS_> // 设置回调函数参考上文<<模板类>>支持任意参数
	int setConnectedCallback(_FUNCTION_ func, _ARGS_... args) {	
		m_connectedcallback = new CConnectedFunction<_FUNCTION_, _ARGS_...>(func, args...);
		if (m_connectedcallback == NULL) return -1;
		return 0;
	}
	template<typename _FUNCTION_, typename... _ARGS_>
	int setRecvCallback(_FUNCTION_ func, _ARGS_... args) {
		m_recvcallback = new CReceivedFunction<_FUNCTION_, _ARGS_...>(func, args...);
		if (m_recvcallback == NULL) return -1;
		return 0;
	}
protected: // 以下两个可调用对象，1->支持一个延迟传参(CSocketBase* pClient) 2->支持两个延迟传参(CSocketBase*, const Buffer&)
	CFunctionBase* m_connectedcallback; // 连接完成后的回调函数
	CFunctionBase* m_recvcallback; // 收到网络用户请求的回调函数
};
```

```C++
// 成员方法

int Init(CBusiness* business, const Buffer& ip, short port) // para1:业务接口
{   // 1.设置子进程(业务处理进程)入口函数 2.创建子进程 3.开启线程池 4.创建epoll 
	// 5.创建监听套接字 6.监听套接字挂树 7.给线程池派发任务
	m_business = business;
	// 由于BusinessProcess是类的一个成员函数，要给他一个类对象的this指针，且还是虚函数，传什么派生类的对象就会执行派生类的逻辑，这里还是多态
	m_process.SetEntryFunction(&CBusiness::BusinessProcess, m_business, &m_process); // 设置子进程的进程入口函数
	m_process.CreateSubProcess(); // 创建子进程
	m_pool.Start(2); // 主进程开启线程池
	m_epoll.Create(2); // 主进程的epoll
	m_server = new CSocket(); // 主进程的监听套接字(网络)
	m_server->Init(CSockParam(ip, port, SOCK_ISSERVER | SOCK_ISIP | SOCK_ISREUSE)); // 主进程监听套接字初始化[(socket() bind() listen()]
	m_epoll.Add(*m_server, (EpollData)((void*)m_server)); // 主进程监听套接字挂epoll树
	for (size_t i = 0; i < m_pool.Size(); i++) { // 主进程给线程池发送任务
		m_pool.AddTask(&CServer::ThreadFunc, this);
	}
	return 0;
}

int CServer::ThreadFunc()
{	// 1.多线程共享epoll树根 2.epoll_wait()，返回的事件只有accept()客户端的connect()
    // 3.accept()后得到与客户端的通信套接字对象 4.将通信套接字发送给子进程(业务处理) 
	EPEvents events;
	while ((m_epoll != -1) && (m_server != NULL)) {
		ssize_t size = m_epoll.waitEvents(events, 500);
		for (ssize_t i = 0; i < size; i++)
		{
			 // 主模块根本不处理客户端的收发，只负责连接客户端，得到通信套接字fd，然后交由子进程处理
			if (events[i].events & EPOLLIN) { // 发生可读事件 EPOLLOUT->可写 EPOLLRDHUP->对端关闭连接 EPOLLET->边缘触发
				CSocketBase* pClient = NULL; // 创建通信套接字对象
				ret = m_server->Link(&pClient); // accept 同时初始化了通信套接字对象(二级指针出参)
				m_process.SendSocket(*pClient, *pClient); // 将通信套接字及其地址发送给子进程 主模块只负责处理连接，后续的通信一概不管
			}
		}
	}
	return 0;
}
```

## 客户端处理进程(业务模块)

**功能**：接收客户端连接服务器(父进程)发来的连接套接字，处理连接套接字上发生的I/O事件(主要包括**连接回调** + **接收回调**)

**组成**：epoll + 线程池 + 数据库 继承自客户端处理的接口类**CBusiness**

```c++
// 成员变量
CEpoll m_epoll; // 客户端处理模块的epoll,用于监听连接套接字的I/O事件
CThreadPool m_pool; // 线程池，用于处理网络用户的I/O请求
std::map<int, CSocketBase*> m_mapClients; // 套接字与套接字对象映射表 就是管理客户端处理模块的通信套接字呗 
unsigned m_count; // 客户端处理模块的线程个数
CDatabaseClient* m_db; // 数据库
protected: // 继承自业务接口基类
	CFunctionBase* m_connectedcallback; // 连接完成后的回调函数
	CFunctionBase* m_recvcallback; // 收到网络用户请求的回调函数
```

```C++
// 成员方法
// 1.连接回调函数
int Connected(CSocketBase* pClient) {
    //客户端连接服务器(主进程)发来了连接套接字， 简单打印一下客户端信息
    sockaddr_in* paddr = (sockaddr_in*)*pClient;
    TRACEI("client connected addr %s port:%d", inet_ntoa(paddr->sin_addr), paddr->sin_port);
    return 0;
}
// 2.接收回调函数 
int Received(CSocketBase* pClient, const Buffer& data) {
	//TODO:主要业务，在此处理 即客户端处理进程中，线程池(子线程)干的事
	// 01.HTTP 解析
	Buffer response = "";
	ret = HttpParser(data); // 1.解析Http请求 2.处理登录 3.查询数据库检查登录请求
	// 02.验证结果的反馈， 即发送http响应包给用户
	response = MakeResponse(ret); // 响应包
	ret = pClient->Send(response);
	return 0;
}
// 3.客户端处理进程的具体业务(对业务接口类中业务处理这一纯虚函数的重写)
virtual int BusinessProcess(CProcess* proc) {
    // 1.连接数据库并创建表 2.设置连接回调函数&接收回调函数 3.创建epoll树根 
	// 4.启动线程池 5.给线程池中的所有子线程分配任务ThreadFunc
	// 5.将连接服务器(主进程)发来的通信套接字挂树(自己的epoll树) 6.调用连接回调函数
	using namespace std::placeholders;
	m_db = new CMysqlClient(); // 初始化数据库
	KeyValue args; // 连接数据库需要的数据
	args["host"] = "10.170.141.3";
	args["user"] = "Yyh";
	args["password"] = "123456";
	args["port"] = 3306;
	args["db"] = "Yyh";
	m_db->Connect(args); // 连接数据库
	edoyunLogin_user_mysql user; // 新表
	m_db->Exec(user.Create()); // 创建表
	// 下面的见上文《模板类》
	setConnectedCallback(&CEdoyunPlayerServer::Connected, this, _1); // 设置连接回调函数(传this，因为Connected()是一个成员函数 _thiscall)
	etRecvCallback(&CEdoyunPlayerServer::Received, this, _1, _2); // 设置接收回调函数 std::placeholders_1/_2 都是占位符 告诉可变参数的模版函数，我还没有确定参数是什么，但是位置先占好
	m_epoll.Create(m_count); // 创建epoll树根(eventpoll)
	m_pool.Start(m_count); // 启动线程池
	for (unsigned i = 0; i < m_count; i++) { // 给线程池所有线程分派任务
		ret = m_pool.AddTask(&CEdoyunPlayerServer::ThreadFunc, this);
	}
	int sock = 0;
	sockaddr_in addrin; // 用于存放主模块发来的客户端地址
	while (m_epoll != -1) { // 将主模块发来的通信套接字挂树
		proc->RecvSocket(sock, &addrin); // 接收主模块发过来的与网络用户的通信套接字及其地址
		CSocketBase* pClient = new CSocket(sock); // 根据通信套接字新建套接字对象
		pClient->Init(CSockParam(&addrin, SOCK_ISIP));
		m_epoll.Add(sock, (EpollData)(void*)pClient); // 通信套接字挂树，注意是挂在客户端处理模块的epoll树上
		(*m_connectedcallback)(pClient); // 连接回调 打印主进程(服务器)发给我们的连上来的用户的ip和端口
	}
	return 0;
}

// 4.客户端处理进程的线程池中线程函数
int ThreadFunc() { 
	EPEvents events; // 1.线程池中的所有线程共享epoll树根 2.等待epoll上事件(网络用户套接字的可读事件)发生 3.调用接收回调函数
	while (m_epoll != -1) {
		ssize_t  size = m_epoll.waitEvents(events);
		for (ssize_t i = 0; i < size; i++)
		{
			if (events[i].events & EPOLLIN) { // 通信套接字上有可读事件
				CSocketBase* pClient = (CSocketBase*)events[i].data.ptr;
				if (pClient) {
					Buffer data;
					pClient->Recv(data); // 读内核接收缓冲区
					if (m_recvcallback) { // 需要接收回到
						(*m_recvcallback)(pClient, data); // 回调，验证登录+http响应
					}
				}
			}
		}
	}
	return 0;
}
```

## http解析

**功能**：解析客户端发来的HTTP请求、解析URL

**组成**：1.创建CHttpParser类来封装开源的、面向过程的 http_parser  2.创建UrlParser类来解析URL

**http_parser**:

```C++
// 使用http解析器 http_parser 的流程：
// 1.设置回调(callback)： http_parser_settings settings; settings.on_url = on_url; ...
// 2.定义并初始化解释器：http_parser parser; http_parser_init(&parser, HTTP_REQUEST);
// 3.解析： http_parser_execute(&parser, &settings, data, strlen(data)); 
// para1:http解析器实例的指针 para2：http_parser_settings结构体的指针，包含了解析器的配置和回调函数
// para3:待解析的数据的指针 para4:待解析的数据的长度 return：成功解析的数据长度
```

**CHttpParser**:

```C++
// 我们是如何将基于C语言的http_parser封装成面向对象的:
// 1.CHttpParser类中包含成员对象 http_parser 初始化时将http_parser.data 设置为当前类实例的this指针
// 2.http_parser_settings中的回调函数声明为静态函数，同时声明对应的成员函数
// (由于回调需要是静态函数或标准调用函数，C++中不能用标准调用函数作为类的成员函数，故只能通过静态函数来设置)
// 3.回调函数内(参数都会有一个http_parser*)，通过http_parser*->data 得到this指针
// 4.再用this指针调用对应的成员函数,将解析值赋给类的成员变量

//成员函数：
size_t Parser(const Buffer& data); // 解析函数，调用http_parser_execute, 解析http请求(data)
static int OnMessageBegin(http_parser* parser); // http 解析开始时的事件
// para1:指向当前HTTP解析器实例的指针 para2:指向包含URL的字符串的指针。这个指针指向原始输入数据的某个位置 para3:表示URL字符串的长度
// para2和para3是解析器自己得到的，当解析器检测到请求行中的URL时，它会调用on_url回调函数，并传递当前解析器状态和URL数据
static int OnUrl(http_parser* parser, const char* at, size_t length); 
static int OnStatus(http_parser* parser, const char* at, size_t length); // para2：状态信息起始位置 para3：状态信息长度
static int OnHeaderField(http_parser* parser, const char* at, size_t length); // para2:头部字段名(即Key "Connection:")的起始位置 para3:头部字段名长度
static int OnHeaderValue(http_parser* parser, const char* at, size_t length); // para2:头部字段值(即Value "Keep-Alive")的起始位置 para3:头部字段值长度
static int OnHeadersComplete(http_parser* parser); // 头部(header)解析完成时的事件
static int OnBody(http_parser* parser, const char* at, size_t length); // para2:body起始位置 para3:body长度
static int OnMessageComplete(http_parser* parser); // http 解析完成时的事件
```

## mysql封装---实现对象关系映射(ORM)

**功能**：封装mysql，实现**对象关系映射**

**组成**：列 -> 表 -> 库

**列类**: `_ mysql_field_`

```C++
// 成员变量
Buffer Name; // 名称
Buffer Type; // 类型
Buffer Size; // 数据库SQL语句中用的到size
unsigned Attr; // 属性：唯一性、主键、非空...
Buffer Default; // 默认值
Buffer Check; // 约束条件

unsigned Condition; // 操作条件 SQL_INSERT->插入 SQL_MODIFY->修改 SQL_CONDITION->条件 这三种操作的组合
union {
    bool Bool;
    int Integer;
    double Double;
    Buffer* String;
}Value; // 列的值
int nType; // 列的值的类型
```

```C++
// 为属性和操作以及值类型构建了枚举类型（位掩码），`|`按位或来设置，`&`按位与来判断
enum { // 标志位
	SQL_INSERT = 1,//插入的列
	SQL_MODIFY = 2,//修改的列
	SQL_CONDITION = 4//查询条件列
};

enum { // 标志位(列属性) 
	NONE = 0,
	NOT_NULL = 1, // 非空
	DEFAULT = 2, // 默认
	UNIQUE = 4, // 唯一
	PRIMARY_KEY = 8, // 主键
	CHECK = 16, // 约束
	AUTOINCREMENT = 32 // 自动增长
};

using SqlType = enum { // 列的数据类型
	TYPE_NULL = 0, // 空类型
	TYPE_BOOL = 1, 
	TYPE_INT = 2,
	TYPE_DATETIME = 4, // 日期时间类型 
	TYPE_REAL = 8, // 小数类型
	TYPE_VARCHAR = 16,
	TYPE_TEXT = 32,
	TYPE_BLOB = 64 // 字符串
};
```

```c++
// 成员方法：
// 1.列定义(返回对应的SQL语句)
virtual Buffer Create(); // eg: `id` INT NOT NULL AUTO_INCREMENT  `name` VARCHAR(255) NOT NULL DEFAULT "default_name"  这些语句用于创建表
// 2.根据str设置列的值
virtual void LoadFromStr(const Buffer& str); // 用于获取结果集时，将结果集中的值赋给结果表对应的列
// 3.where 语句使用的:生成等于表达式
virtual Buffer toEqualExp() const; // eg:SELECT * FROM table WHERE column_name = value DELETE FROM table WHERE column_name = value
// 4.值转字符串
virtual Buffer toSqlStr() const; // 将字段的值转字符串用于插入表的语句 INSERT INTO 表全名 (列名,...)VALUES(值,...)； 这里就是为了得到值
// 5.重载类型转换，获取列的全名
virtual operator const Buffer() const; // eg: `id`
```

**表类**: `_ mysql_table_`

```C++
// 成员变量 
Buffer Database; // 表所属的DB的名称
Buffer Name; // 表名
FieldArray FieldDefine; // 表的所有列对象指针
FieldMap Fields; // 列名及其列对象指针的映射表
```

```C++
// 成员方法
// 1.返回创建表的SQL语句 放到数据库类的exec()中去执行，才能实现创建表，这个函数本身并不是创建表
// CREATE TABLE table_name (column1 datatype constraints, column2 datatype constraints, ... primary key(column_name));
virtual Buffer Create(); // eg:CREATE TABLE `Persons` ( `ID` INTEGER NOT NULL AUTO_INCREMENT, ..., PRIMARY KEY (`ID`));
// 2.删除表(返回对应的SQL语句)
virtual Buffer Drop(); // eg:DROP TABLE `Persons`;
// 3.增删改查(返回对应的SQL语句)
virtual Buffer Insert(const _Table_& values); // eg: INSERT INTO `Persons` (`ID`) VALUES (123);
virtual Buffer Delete(const _Table_& values); // eg: DELETE FROM `Persons` WHERE `ID` = 123;
virtual Buffer Modify(const _Table_& values); // eg: UPDATE `Persons` SET `ID`=456 WHERE `ID` = 123;
virtual Buffer Query(const Buffer& condition); // eg:SELECT `ID` FROM `Persons` WHERE 'ID' = 123;
// 4.通过拷贝构造创建当前表对象的一个副本  
virtual PTable Copy() const; //  每次遍历结果集的一行数据时，都会调用 Copy() 来创建一个新的表对象副本，然后根据查询结果填充这个副本的列值
virtual void ClearFieldUsed(); // 清空表的所有列的标志(插入、修改、查询条件) 这些标志是在main中设置的 eg:value.Fields["user_qq"]->Condition = SQL_MODIFY;
```

**数据库类**: `CMysqlClient`

```c++
// 成员变量
MYSQL m_db; // MYSQL 结构体，表示一个 MySQL 连接对象
bool m_bInit;// 默认是false 表示没有初始化 初始化之后，则为true，表示已经连接
```

```c++
// 成员方法：
// 1.连接 KeyValue 是一个string->string的map，记录了"host" "user" "password" "db" "port"等参数用于连接数据库
virtual int Connect(const KeyValue& args); // call: mysql_real_connect() 
// 2.执行 sql 即要执行的 mysql 语句
virtual int Exec(const Buffer& sql); // call: mysql_real_query()
// 3.带结果的执行 sql 即要执行的 mysql 语句 Result是一个表指针列表，存放结果集 table用来存储每一行的查询结果然后放入Result中
// 4.call:mysql_real_query() mysql_store_result() mysql_num_fields() mysql_fetch_row()
virtual int Exec(const Buffer& sql, Result& result, const _Table_& table); 
// 5.开启事务
virtual int StartTransaction(); // call：mysql_real_query(&m_db, "BEGIN", 6);
// 6.提交事务
virtual int CommitTransaction(); // call：mysql_real_query(&m_db, "COMMIT", 7);
// 7.回滚事务
virtual int RollbackTransaction(); // call：mysql_real_query(&m_db, "ROLLBACK", 9);
// 8.关闭连接
virtual int Close(); // call：mysql_close(&m_db);
// 9.是否连接
virtual bool IsConnected();
```

**宏定义**：简化创建表对象和列对象的操作

```c++
#define DECLARE_TABLE_CLASS(name, base) class name:public base { \
public: \
virtual PTable Copy() const {return PTable(new name(*this));} \
name():base(){Name=#name;

#define DECLARE_MYSQL_FIELD(ntype,name,attr,type,size,default_,check) \
{PField field(new _mysql_field_(ntype, #name, attr, type, size, default_, check));FieldDefine.push_back(field);Fields[#name] = field; }

#define DECLARE_TABLE_CLASS_EDN() }};
```

![image-20240608202222289](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745030.png) 

上面的语句展开后：

![image-20240608202247911](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745032.png) 

继承`_mysql_table_`创建了一个表类，表中有四个列对象

## MD5加密

**功能**：网络客户端 MD5(时间，密钥，密码，盐)得到**数字签名**，再将 **时间 + 盐 + 用户名 + 数字签名** 做http请求发送给服务器 (密码没有传输)

​			服务器这边收到后，查数据库得到该用户名的密码，然后MD5(时间，密钥，密码，盐)得到哈希值，比较**哈希值与数字签名是否匹配**，匹配则登录验证成功

![image-20240608205236703](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745033.png) 

![image-20240608205304531](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745034.png) 

# 远控项目复盘

## 服务器

#### 单例模式---用于服务器套接字类

- **定义**：是一种软件设计模式，其核心思想是确保**类在应用程序的生命周期内只有一个实例**，并提供一个**全局的访问点**。这意味着无论何时何地请求这个类的实例，都将**返回相同的对象**。单例模式通常用于管理全局资源、共享配置信息、或者提供唯一的访问点来控制某些资源

- **实现**：1. 私有化它的构造析构函数  2.使用类的私有静态指针变量指向类的唯一实例  3.使用一个公有的静态方法获取该实例

  ```c++
  class CServerSocket
  {
  public:
  	static CServerSocket* getInstance() { // 3. 使用一个公有的静态方法获取该实例
  		if (m_instance == NULL) {
  			m_instance = new CServerSocket();
  		}
  		return m_instance;
  	}
  private:
  	CServerSocket() {} // 1. 私有化单例类的构造与析构函数
  	~CServerSocket() {} 
  	static CServerSocket* m_instance; // 2. 私有静态指针变量指向单例类的唯一实例
  };	
  ```

- **分类**：1.**懒汉式**：第一次使用时才初始化，延迟初始化  2. **饿汉式**：类产生时就初始化好了

  ```c++
  CServerSocket* CServerSocket::m_instance = NULL; // 懒汉式
  CServerSocket* CServerSocket::m_instance = new CServerSocket(); // 饿汉式 
  ```

- **问题**：

  1. **内存泄漏**：当单例是类实例指针时，由于将**析构函数声明为私有**，无法通过 **delete** 来调用析构函数释放在**堆区的资源**
  2. **线程安全**：
     a. 饿汉单例模式在程序**一开始就初始化好实例**，所以后续**不再需要考虑线程安全**的问题，故适用于线程比较多的程序中，以空间换取时间
     b.  懒汉式单例模式是一种**延迟实例化**的单例模式，在首次使用时才会创建实例。然而，懒汉式单例模式在**多线程环境下可能存在线程安全问题**，在懒汉单例模式中，如果多个线程同时检查实例是否已经创建，并且都发现实例尚未创建，那么它们都会尝试创建一个新的实例。这可能导致多个线程创建了多个实例，违反了单例模式的原则（多线程下的**竞态条件**）

```c++
// 内存泄漏的解决：
// 方法1：在类中再写一个主动释放资源的方法，声明为公有静态，然后手动调用该方法来释放资源
static void releaseInstance()
{
    if (m_instance != NULL)
    {
        CServerSocket* tmp = m_instance;
        m_instance = NULL;
        delete tmp;
    }
}

// 方法2：定义一个内部嵌套垃圾回收类(这也是我们在这个项目中采用的方法)
class CHelper
{ 	// CHelper 类是一个嵌套类（nested class），它被声明为 CServerSocket 类的私有内部类
    public:
    CHelper() // 嵌套类，可以访问 CServerSocket 类的私有成员
    {        
        CServerSocket::getInstance();
    }
    ~CHelper() 
    {		  
        CServerSocket::releaseInstance();
    }
};

static CHelper m_helper; // 定义一个内部类的静态对象 当该对象销毁的时候，调用析构函数顺便销毁单例对象 m_instance

// 方法3：智能指针 + 自定义删除器
```

- **适用场景**: 懒汉模式适用于线程比较少的场景，因为线程一旦多，加锁的开销就会体现出来；饿汉模式适用于线程比较多的场景，它会占用全局静态区一定的空间，但是能够确保只有一个实例。

### 数据包的封装设计

![image-20240613170205288](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847940.png) 

- 成员变量：

![image-20240613170437525](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847941.png) 

- 成员函数：

![image-20240613170943216](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847942.png) 

- 文件信息结构体：

![image-20240613171138690](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847943.png) 

- 鼠标操作结构体：

![](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847944.png) 

### 服务器的main()

**初始化套接字 -> 接收客户端连接请求 -> 接收并解析客户端的消息,返回客户端的控制命令 -> 根据控制命令执行相应的业务逻辑 -> 若有需要则返回消息给客户端**

- **查看磁盘分区**
- **查看指定目录下的文件**
- **打开文件**
- **下载文件**
- **鼠标操作**
- **发送屏幕截图**
- **锁机**
- **解锁**
- **删除文件**

# 计算机网络

## HTTP/HTTPS

```c++
// 1. http 与 https 的区别及其各自优缺点？
```

==**区别**==： 

| http                                 | https                   |
| :----------------------------------- | ----------------------- |
| 明文传输，不安全（监听、篡改、劫持） | 密文传输+身份认证，安全 |
| port: 80                             | port: 443               |
| TCP握手                              | TCP握手 + SSL握手       |
| 无需向服务端申请证书                 | 需要到CA申请证书        |

==**优缺点**==：

|      | http                                                         | https                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 简单、灵活、易扩展、应用广                                   | 1. 传输数据过程中，使用密钥对传输的数据进行**加密**，安全性较高<br />2. 可以对用户和服务器进行**认证**，确保了数据传送的完整性和准确性,保证信息不被窃听，篡改和劫持 |
| 缺点 | 以明文的方式在网络中传输数据，通信内容容易被**窃听、篡改、劫持**，无法保证数据的完整性和准确性，因此使用HTTP协议传输数据**不安全** | 1.HTTPS协议**握手阶段延时较高**： 由于在进行HTTP会话前，还需要进行**SSL握手**，所以HTTPS协议握手阶段延时会适当增加。<br />2.HTTPS协议**部署成本高**： 首先，HTTPS协议需要购买**CA证书**，通过证书来验证自身的安全性；其次，HTTPS属于加密传输协议，需要进行**加密、解密的计算与操作**，会占用一定数量的CPU资源，因此，需要的服务器配置、数目相对较高 |

```c++
// 2.请你描述一下从输入网址到网页完全打开的整个过程是怎样的?
```

| 1.DNS域名解析        | 客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址<br />解析顺序：浏览器缓存->系统缓存->本地DNS解析->根DNS解析->顶级DNS解析->权限DNS解析 |
| -------------------- | ------------------------------------------------------------ |
| 2.建立TCP连接        | 获得服务器IP之后，就需要**三次握手**的协议才能建立连接<br />①客户端发送SYN包请求 -> <br />②服务器确认收到SYN包请求同时自己返回一个包给客户端，即返回SYN+ACK -><br />③客户端收到SYN+ACK包之后，返回给服务器一个确认包 ACK 包表示收到，然后双方达成协议，建立连接<br />如果是HTTPS协议，还有**SSL**的握手 |
| 3.发送HTTP/HTTPS请求 | 与服务器建立连接之后，就可以向服务器发送请求包了，请求需要遵循http/https协议 |
| 4.服务器处理请求     | 被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据(响应包)给客户端 |
| 5.返回响应结果       | 给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常。如果返回异常，就会展示对应的错误信息<br />`100 Continue` 客户端的部分请求已被接收，且仍未被拒绝<br />`200 OK` 请求成功，正常状态，表示服务器已成功处理了客户端的请求<br />`301 Moved Permanently`  请求的网页已永久移动到新位置<br />`400 Bad Request`  语义有误，当前请求无法被服务器理解。或者是请求参数有错误<br />`404 Not Found` 请求失败，资源不存在，可能是输入的URL错误或资源被删除or移动到其他位置<br />`500 Internal Server Error` 一般来说，这个问题都会在服务器端的源代码出现错误时出现、配置问题or资源不足 |
| 6.浏览器渲染         | 返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现 |
| 7. 断开连接          | 数据传输完毕，需要断开tcp连接，此时tcp发起4次挥手            |

```c++
// 3.HTTP报文的结构
```

**==请求报文==**：

![image-20240609140259619](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745035.png) 

![image-20240609140645433](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745036.png) 

**==响应报文==**：

![image-20240609140822118](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745037.png) 

![image-20240609140849779](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745038.png) 

```c++
// 4. http的keep-alive是如何实现？有什么用途？
```

**实现**：HTTP 的 **`Keep-Alive`** 是通过在 HTTP **请求头**中增加一个参数来实现的，这个参数是 **`Connection: keep-alive`**。当客户端和服务器之间的通信使用了Keep-Alive 参数时，它指示服务器在发送完响应后**保持 TCP 连接**打开状态，以便后续的请求可以继续复用这个连接，而不必每次都重新建立连接。

**用途**：

| 1.减少连接建立和断开开销 | 在传统的 HTTP 中，每次请求都需要建立一个新的 TCP 连接，完成请求后又需要断开连接。而使用 Keep-Alive 功能可以让客户端和服务器在一次连接中完成多个请求和响应，避免了重复的 TCP 连接的建立和断开过程，从而减少了连接的开销 |
| ------------------------ | ------------------------------------------------------------ |
| 2.提高性能和效率         | 减少了连接的建立和断开次数可以提高通信的效率和性能。特别是在一些高并发的场景下，使用 Keep-Alive 功能可以显著减少服务器的负担，提高了系统的吞吐量。 |
| 3.优化网络资源利用       | 使用 Keep-Alive 功能可以更有效地利用网络资源，减少了因频繁建立和断开连接而造成的网络资源浪费。尤其是在网络延迟较高的情况下，复用连接可以减少网络传输的等待时间，提高了网络资源的利用率。 |
| 4.改善用户体验           | 减少了连接的建立和断开次数可以加快页面加载速度，提高了用户访问网站的体验。特别是对于一些需要频繁请求资源的网页应用，使用 Keep-Alive 功能可以明显改善用户的响应速度和流畅度。 |

 

```C++
// 5.GET 和 POST 的区别
```

| GET的语义是从服务器获取指定的资源                            | POST 的语义是根据请求负荷（报文body）对指定的资源做出处理    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| GET把请求的数据放在URL上，以`?`分割URL和传输数据，参数之间以`&`相连 | POST把数据放在HTTP的包体(报文body)内                         |
| GET产生**一个**TCP数据包，浏览器会把http header 和 data 一并发送出去，服务器响应 `200 OK`(返回数据) | POST产生**两个**TCP数据包，浏览器先发送header，服务器响应`100 Continue`,浏览器再发送data，服务器响应 `200 OK`(返回数据) |
| GET请求会被浏览器主动缓存                                    | POST请求不会被浏览器主动缓存                                 |
| GET是**幂等**的，即多次执行相同的操作，结果都是「相同」的    | POST**不是幂等**的                                           |

## TCP/IP

```c++
// 1.网络分层模型，各层的作用以及为什么要分层?
```

| 分层       | 作用                                                         | 常用协议         |
| ---------- | ------------------------------------------------------------ | ---------------- |
| 应用层     | 直接与用户交互，提供应用服务和网络应用的接口，不用去关心数据是如何传输的 | HTTP、FTP、DNS等 |
| 传输层     | 负责数据(Segments)的可靠传输，提供端到端的通信服务           | TCP、UDP         |
| 网络层     | 负责数据包(Packets)的路由选择和转发，实现不同网络之间的互联  | IP、ICMP、ARP    |
| 网络接口层 | 负责数据帧(Frames)的传输，确保在同一网络内的节点间可靠传输数据 | 以太网、Wi-Fi    |

为什么要分层：==**解耦并屏蔽底层细节**==
a. **简化复杂性**：分层将复杂的网络通信问题分解成更小的、易于管理的部分，每一层都只关注其特定的功能
b. **独立开发**：每一层的协议和实现可以独立开发和演化，而不需要改变其他层
c. **灵活性**：由于各层独立，新的协议和技术可以更容易地集成到现有的体系结构中。例如，可以在传输层引入新的传输协议，而无需改变应用层协议
d.**故障隔离**：如果网络通信出现问题，分层设计可以帮助快速定位问题所在的层，从而更有效地解决问题

```c++
// 2.TCP与UDP的区别？
```

| 区别               | TCP (Transmission Control Protocol)                          | UDP (User Datagram Protocol)                                 |
| :----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接               | 面向连接的传输层协议，传输数据前先要建立连接                 | 不需要连接，即刻传输数据                                     |
| 服务对象           | 一对一的两点服务，即一条连接只有两个端点                     | 支持一对一、一对多、多对多的交互通信                         |
| 可靠性             | 可靠交付数据，数据可以无差错、不丢失、不重复、按需到达       | 尽最大努力交付，不保证可靠交付数据                           |
| 流量控制、拥塞控制 | 有拥塞控制和流量控制机制，保证数据传输的安全性               | 没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率          |
| 首部开销           | 首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的 | 首部只有 8 个字节，并且是固定不变的，开销较小                |
| 传输方式           | 流式传输，没有边界，但保证顺序和可靠                         | 一个包一个包的发送，是有边界的，但可能会丢包和乱序           |
| 数据包大小         | 数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片 | 数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层 |
| 应用场景           | FTP 文件传输 、 HTTP / HTTPS                                 | 视频流、在线游戏、实时语音（VoIP）、DNS查询                  |

```C++
// 3.TCP粘包问题？
```

**问题**：TCP粘包是指在使⽤TCP进行数据传输的过程中，发送⽅发送的多个数据包会被接收方⼀次性接收，导致多个数据包黏在⼀起，这通常是因为tcp的传输是基于**字节流**的，**不保证数据的边界**所引起的。多个应用层消息可能会被合并成一个TCP段发送，或一个应用层消息可能会被拆分成多个TCP段接收，这就导致了粘包

**原因**：

a. Nagle算法通过将小的数据包合并成一个较大的数据包发送，以减少网络上的小包数量。这种合并发送可能导致粘包。

b. 当发送的数据量较小时，TCP会尽可能地将多个小数据包合并成一个数据包发送，以提高网络利用率

c. 接收方从TCP缓冲区读取数据时，如果读取操作不够及时或一次性读取的数据量较大，可能会一次性读取多个应用层消息，导致粘包

**解决办法**：

a. 添加消息边界：在发送数据时，给数据包添加⼀个特殊的边界标识，比如换行符或特殊字符。接收方在接收数据时，根据数据标识堆数据包进行拆分。
b. 使用定长消息：约定每个数据包的长度固定。如果数据长度不足，那么就用特定字符去填写。这个方法适合于数据包长度固定的场景，但是可能会导致数据传输的效率降低。
c. 添加消息头：在发送数据的时候，为数据包添加⼀个消息头，在消息头中包含数据包的长信息。接收⽅在接收数据时，先解析消息头，获取数据包长度，然后根据长度对数据包进行拆分。
d. 使⽤应⽤层协议：使⽤HTTP或者FTP等协议，这些协议都已经解决了粘包问题

```c++
// 4.UDP会发生粘包吗？ UDP为什么会有乱序问题？ 为什么先发的包不会先到呢？
```

a. UDP本身不会发⽣粘包。UDP是基于数据报的协议，发送发的数据报时独⽴的，因此有明确的边界。当接收⽅收到UDP的数据报时，会根据数据报的边界进行数据处理，因此不会发⽣粘包

b. UDP中不像tcp中，有滑动窗口，序列号，确认应答和超时重传的机制，所以由于⽹络抖动等问题，数据包并不是按照先后顺序到达的，并且UDP本身没有做可靠传输的处理，所以使用UDP，会存在乱序问题，需要自己处理

c. 在数据包发送的过程中，数据包需要经过多个路由器和交换机才能到达目的地。这些设备会根据当前网络的网络状况和拥塞情况调整数据的路径。因此，及时从同⼀源地址发送到同⼀目的地址的两个数据包，它们的路径也不同，每条路径的拥塞情况，数据包丢失情况和重传情况都不同，所以它们的到达顺序可能会不同

```c++
// 5.TCP 3次握手的过程？
```

a. 一开始，客户端和服务端都处于`CLOSE`状态，先是服务端主动监听某个端口进入`LISTEN`状态

b. 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。

c. 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态

d. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态

e. 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态

```c++
// 6.建立TCP连接，后续如果数据包有损坏和乱序，是如何处理的？
```

| 异常    | 如何处理                                                     |
| ------- | ------------------------------------------------------------ |
| a. 损坏 | 在发送端，TCP 会计算发送数据的**校验和**存储在头部，如果数据包在传输过程中损坏（比如由于噪声、信号衰减等原因），接收端的 TCP 层会检测到校验和不匹配的情况。当接收到损坏的数据包时，TCP 不会通知应用层（例如浏览器或下载管理器），而是**直接丢弃**这个数据包，然后请求发送端**重新发送**丢失或损坏的数据。【重传机制下面会介绍】 |
| b.乱序  | TCP 使用**序列号和确认号**来对传输的数据包进行**排序和确认**，接收端会根据每个数据包的序列号（Sequence Number）来确认数据包的顺序。如果接收到的数据包不是按顺序到达的（即出现乱序），TCP 接收端会将乱序的数据包**缓存**起来，直到所有数据包都按正确的顺序到达。一旦所有数据包都到达并按顺序排列，TCP 协议会将这些数据包按序交付给应用层。 |

```c++
// 7. TCP 遇到网络拥塞或者大流量的情况如何去做？
```

| a. 拥塞检测    | TCP 通过丢包和超时来检测网络拥塞。当发生丢包(收到连续相同的ACK)时，TCP 会认为网络存在拥塞，并采取相应的拥塞控制策略 |
| -------------- | ------------------------------------------------------------ |
| b.拥塞控制策略 | 当检测到网络拥塞时，TCP 会降低发送速率，通过减小拥塞窗口大小来控制数据包的发送速率，以便减少对网络的负载。TCP 使用拥塞避免算法来逐步增加拥塞窗口的大小，但会避免过快地填充网络，从而降低出现拥塞的可能性 |
| c. 动态调整    | TCP 协议会根据网络状态实时动态调整拥塞窗口的大小和发送速率，以适应网络的变化，从而实现稳定的数据传输。总之就是**慢启动**、**拥塞避免**、**快恢复**等机制，以及拥塞窗口的动态调整，基于这些机制来保证传输的**可靠和稳定** |

```c++
// 7. TCP 重传机制？
```

| 重传机制                   | 方法                                                         | 关键                                                         |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| a. 超时重传                | 发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据 | 确定超时重传时间(RTO)，如果超时时间**长了**，网络的空隙时间增大，降低了网络传输效率；如果**短了**，可能导致没有丢就重发，导致网络负荷增大。<br />==**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**== |
| b. 快速重传                | 以数据驱动重传，**三次同样**的`ACK`，就会触发重传            | ==**重传的时候，是重传一个，还是重传所有的问题**==。如果重传一个，效率很低，还要收到下一个的三次`ACK`才能触发重传。如果重传所有，有可能后面的是已经接收过的，浪费资源 |
| c. 选择性确认(`SACK`)      | 在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据** |                                                              |
| d. 重复选择性确认(`D-ACK`) | 使用了 SACK 来告诉「发送方」有哪些数据被**重复接收**了       | 1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了; <br />2. 可以知道是不是「发送方」的数据包被网络延迟了; <br />3. 可以知道网络中是不是把「发送方」的数据包给复制了 |

```c++
// 8. TCP 流量控制？
```

- 窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**
- TCP头部的 `Window` 字段：指定了窗口大小用于**接收端告诉发送端自己还有多少缓冲区可以接收数据**。发送端可以根据接收端的处理能力来发送数据，而不会导致接收端处理不过来，故TCP中窗口大小是由接收方的窗口大小决定的
- **滑动窗口**：发送但未收到`ACK`的数据都要缓存，直到收到对应的`ACK`后方可滑动窗口
- 如果发送方收到接收方窗口大小=0的`ACK`报文，就不会再发送数据，但会启动一个计时器，超时后发送**窗口探测报文**， 防止接收端的窗口通知报文丢失导致**死锁**
- **糊涂窗口综合症**：如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是**糊涂窗口综合症**。

```c++
// TPC + IP 头部至少有40字节，如果每次只为了传几个字节的数据，就很浪费
糊涂窗口综合症的原因：a. 接收方可以通告一个小的窗口 b. 而发送方可以发送小数据
解决方案：a. 让接收方不通告小窗口给发送方 b. 让发送方避免发送小数据

// 接收方:
窗口大小小于min(MSS, 缓存空间/2), 就会把窗口大小置0
// 发送方：
Nagle算法(延时处理): a. 要等到窗口大小 >= MSS 并且 数据大小 >= MSS  <or> b. 收到之前发送数据的 ack 回包
如果上面两个条件都不满足，发送方就会一直囤积数据
```

```C++
// 9. TCP 拥塞控制？
```

- **慢启动**：发送方每收到一个 `ACK`, 拥塞窗口`cwnd`大小`+1` (指数增长)

- **拥塞避免**：`cwnd` > `ssthresh`(慢启动门限,一般为`65535`)，就会进入拥塞避免，发送方每收到一 个`ACK`, 拥塞窗口`cwnd`大小`+1/cwnd` (线性增长)

- **超时重传的拥塞恢复**：`ssthresh` 设为 `cwnd/2`，`cwnd` 重置为初始值   eg：发生超时重传时，`cwnd=1000` ---> `cwnd=init, ssthresh=500`，然后**慢启动**

- **快速重传的拥塞恢复**：`cwnd = cwnd/2` ，也就是设置为原来的一半 ` ssthresh = cwnd `eg:`cwnd=1000` ---> `cwnd=500, ssthresh=500`,然后**快速恢复**

  a. 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）

  b. 重传丢失的数据包

  c. 如果再收到重复的 ACK，那么`cwnd + 1`

  d. 如果收到新数据的 ACK 后，`cwnd = ssthresh` ，原因是该 `ACK `确认了新的数据，说明从` duplicated ACK `时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入**拥塞避免**状态；

```C++
// 10. TCP 四次挥手？
```

   ![image-20240614134459231](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406141945390.png) 

```c++
// 11. TCP 挥手丢失了会怎么样？
```

| 挥手次数       | 机制                                                         |
| -------------- | ------------------------------------------------------------ |
| 第一次挥手丢失 | 第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK(第二次挥手) ，就会触发超时重传机制，重传 FIN 报文，每次超时重传等待时间是上一次的两倍，达到最大重传次数后，如果还是没有收到服务端的第二次挥手，就直接进入 `close` 状态 |
| 第二次挥手丢失 | ACK 报文是不会重传的，所以服务端的第二次挥手丢失了，客户端就会触发超时重传机制，同第一次挥手丢失；<br /> |
| 第三次挥手丢失 | 服务端迟迟收不到客户端的 ACK(第四次挥手)，就会超时重传，达到最大重传次数后就`close`<br />注意如果客户端调用的是 `close()` 来关闭连接，`FIN_WAIT_2` 只会持续60秒，所以迟迟收不到第三次挥手的话，客户端也会`close` |
| 第四次挥手丢失 | ACK 报文是不会重传的，所以客户端的第四次挥手丢失了，服务端就会触发超时重传，一直收不到，达到最大重传次数就会进入`close`；客户端在收到第三次挥手并发送第四次挥手后，就会进入 `TIME_WAIT` 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接 |

```c++
// 12. 为什么 TIME_WAIT 等待的时间是 2MSL？
```

**定义**：主动发起关闭的一方才会有 `TIME_WAIT` 状态，在收到第三次挥手和发送第四次挥手后，就会进入该状态,，时间为 2MSL，在收到第三次挥手的重传后该时间会重置

**为什么要有**: 

1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收，2MSL 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的
2. 等待足够的时间以确保最后的 ACK(第四次挥手) 能让被动关闭方接收，从而帮助其正常关闭，因为第四次挥手如果丢失了(1MSL)，服务端会重传第三次挥手(1MSL)，这样一来一回，刚好能保证服务端收到重传的第三次挥手

```c++
// 13. TIME_WAIT 过多有什么危害？
```

1. 占用系统资源，比如说文件描述符、内存资源、CPU资源、线程资源等
2. 占用端口资源，端口资源也是有限的
3. 还要考虑到主动断开连接的是哪一方
   - **服务器主动断开**：并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等
   - **客户端主动断开**：首先需要明白，客户端的端口是`connect()`之后，内核随机挑选的,但是一个端口号是可以**重用的**，因为TCP连接是依靠==[目的IP，目的端口，源IP，源端口]==这个四元组来唯一确定的，只要这其中一个变化，就可以建立新的连接。所以客户端的同一个端口是可以连接不同IP、不同端口的服务器的。因此，客户端（发起连接方）都是和**「目的 IP+ 目的 PORT 」都一样的服务端**建立连接(就需要使用客户端的端口来做区分了)的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。

```c++
// 14. 如何避免 TIME_WAIT？
```

- `TIME_WAIT`设计出来肯定是有其作用的，如清空历史连接中的数据，让被动关闭方更优雅地关闭，可以服务端永远不要主动断开连接，让客户端去断开，由分布在各处地客户端去承受 `TIME_WAIT`

```c++
// 15.服务器出现大量 TIME_WAIT 状态的原因有哪些？
```

明确，`TIME_WAIT` 是只有==**主动断开连接**==的一方才有的状态

1. ==HTTP 没有使用长连接(`Keep-Alive`)== 如果要关闭长连接，需要在 HTTP 请求或响应包中添加 `Connection:close` 信息，也就是说，只要客户端和服务端任意一方的 HTTP header 中有 `Connection:close` 信息，那么就无法使用 HTTP 长连接的机制。关闭长连接机制后，每次请求都要经历这样的过程：**建立 TCP -> 请求资源 -> 响应资源 -> 释放连接**，那么此方式就是 **HTTP 短连接**。因此，**当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive**，因为任意一方没有开启 HTTP `Keep-Alive`，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 `TIME_WAIT` 状态的连接。针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制
2. ==HTTP 长连接超时== 如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接
3. ==HTTP 长连接的请求数量达到上限==

```c++
// 16.服务器出现大量 CLOSE_WAIT 状态的原因有哪些？
```

明确，`CLOSE_WAIT` 是只有==**被动断开连接**==的一方才有的状态。而且如果「被动关闭方」没有调用 `close()` 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 `CLOSE_WAIT` 状态的连接转变为` LAST_ACK` 状态。所以，**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接**。   (注意，TCP三次握手的建立和`accept()`没有关系，内核已经处理好了，`accept()`只是用于从全连接队列取出建立好的连接罢了)

1. 没有将监听套接字注册到 epoll ，导致新连接到来了服务端收不到事件通知，自然也就无法`accept()`，获取不到通信套接字，自然也就无法调用`close()`
2. 没有调用 `accept()` 接收连接
3. 没有将 `accept()` 上来的通信套接字注册到 epoll ,自然也就无法得知客户端断开连接事件
4. 没有调用 `close()` 或者代码卡在哪里，死锁了

```c++
// 17. 如果已经建立连接，但是客户端突然出现故障了怎么办？
```

客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 `ESTABLISH` 状态，占用着系统资源。

- TCP 的==**保活机制**== ：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。但是需要等待的时间比较长
- 自己在应用层实现==**心跳机制**==：比如，web 服务软件一般都会提供 `keepalive_timeout` 参数，用来指定 HTTP 长连接的**超时时间**。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会**启动一个定时器**，如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，**定时器的时间一到，就会触发回调函数来释放该连接**

# 操作系统 

## 进程&线程

```c++
// 1.进程和线程的区别？
```

| 本质区别：         | 进程是==资源分配==的基本单位                                 | 线程是==CPU调度==的基本单位                                |
| ------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 并发性(切换效率)： | 低：CPU寄存器、程序计数器、用户空间的信息(虚拟内存)内核空间的数据(pcb) | 高：CPU寄存器、程序计数器(**同一**进程下的线程之间)        |
| 内存：             | 进程有==独立的==虚拟地址空间(进程之间运行环境是相互==隔离==的) | 线程==共享==进程的虚拟地址空间，有栈、程序计数器等独立空间 |
| 所属关系：         | 一个进程可以拥有多个线程                                     | 一个线程必须依附于一个进程存在                             |
| 健壮性：           | 高：进程有独立的运行环境(**本质原因**)，一个进程宕机了不会影响其他进程 | 低：一个线程发生异常，同一进程下的所有线程都会宕掉         |

```c++
// 2.进程和线程切换的区别？
```

**上下文切换的过程**：1. 保存当前进/线程的硬件上下文(寄存器状态、当前运行的指令)于内核中 2.修改当前进/线程的PCB(TCB)，修改运行状态(阻塞/就绪)， 存储管理数据的保存 3.修改被调度进/线程的PCB(TCB)，将状态修改为运行 4.存储管理数据的切换 5.恢复硬件上下文，让程序计数器(PC)执行被调度的进程代码

**区别**：主要是上文过程中 **2、4 **

进程需要切换地址空间，线程不需要  

进程切换开销较大，需要保存和恢复大量上下文信息(寄存器、页表、fd) 线程切换开销较小，只需要保存和回复少量的上下文信息(寄存器)

```c++
// 3.什么时候会发生切换
```

| 1. 时间片耗尽（时间片轮转调度）                        | 在多任务操作系统中，时间片轮转（Round-Robin）是一种常用的调度算法。每个线程被分配一个固定的时间片（时间段）来运行。当时间片耗尽时，操作系统会挂起当前线程并调度下一个线程运行 |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| 2. I/O 操作（阻塞）                                    | 当一个线程执行 I/O 操作（例如读写文件、网络通信等）时，它通常会被阻塞，等待 I/O 操作完成。在这段等待时间里，操作系统会挂起该线程并调度其他线程运行 |
| 3. 线程主动让出 CPU                                    | 线程可以通过调用诸如 yield、sleep 或 wait 等方法主动让出 CPU，允许操作系统调度其他线程运行 |
| 4. 线程优先级调度                                      | 操作系统通常会根据线程的优先级来进行调度。当一个高优先级的线程变得可运行时，操作系统可能会中断当前低优先级线程的执行，并调度高优先级线程运行 |
| 5. 线程结束                                            | 当一个线程完成其任务并终止时，操作系统会进行线程切换，调度另一个线程运行 |
| 6. 锁和同步机制                                        | 线程在访问共享资源时通常会使用锁或其他同步机制（如信号量、条件变量等）来避免竞争条件。当一个线程尝试获取一个已被其他线程持有的锁时，它会被阻塞，直到锁被释放。操作系统在这种情况下会调度其他可运行的线程 |
| 7.硬件中断（如定时器中断、I/O 中断等）也会导致线程切换 | 操作系统响应中断后，可能会改变当前线程的运行状态，从而调度其他线程运 |

```c++
// 4.进程调度算法
```

| 1.先来先服务       | 非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长 |
| ------------------ | ------------------------------------------------------------ |
| 2.短作业优先       | 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业 永远得不到调度。 |
| 3.最短剩余时间优先 | 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 |
| 4.时间片轮转       | 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。如果时间片太小，会导致进程切换得太 频繁，在进程切换上就会花过多时间；如果时间片过长，那么实时性就不能得到保证退化成了先来先服务。 |
| 5.优先级调度       | 为每个进程分配一个优先级，按优先级进行调度                   |
| 6.多级反馈队列     | 时间片轮转调度算法和优先级调度算法的结合。设置了多个队列，每个队列时间片大小都不 同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列 |

```c++
// 5.进程间通信(IPC)方式?
```

| 方式         | 做法                                                         | 特点                                                       |
| ------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 1.匿名管道   | 半双工的通信方式，数据只能单向流动，就是两个进程通过操作系统提供的内存空间进行通信，以**无格式的字节流**的形式传输数据  `pipe()` | 单向、只能用于父子进程间通信、数据先进先出                 |
| 2.命名管道   | 同上，在文件系统中以特殊文件形式存在 `mkfifo()`              | 单向、可用于两个独立进程间通信、数据先进先出               |
| 3.消息队列   | 消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型(克服了管道传输的数据类型问题)，发送数据时，会被分成一个一个独立的消息体 `msgget()` | 数据有大小限制、数据的读写需要经过用户态和内核态的拷贝过程 |
| 4.共享内存   | 直接分配一个共享空间，每个进程都可以直接访问， 不需要陷入内核态或者系统调用，大大提高了通信的速度`shmget()` | 最快、多线程的竞态条件，涉及同步互斥                       |
| 5.信号量     | 信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作`sem_init()` | 实现共享资源的互斥访问与线程间的同步                       |
| 6.信号       | 异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件 `signal()` | 异步通知                                                   |
| 7.本地套接字 | 采用套接字通信机制，支持TCP/UDP协议  `socket(PF_LOCAL, SOCK_STREAM, 0)` | 编程复杂度高、结合epoll实现高效并发处理且无需考虑同步互斥  |

## 内存管理

```c++
// 1.为什么要使用虚拟内存？
```

**a. 内存隔离和保护**： 虚拟地址允许每个进程都有自己的地址空间，使得多个进程可以同时运行而互不干扰。每个进程都认为它在独立的内存空间中运行，因此不会直接访问其他进程的内存。这种隔离性可以提高系统的安全性和稳定性，防止程序之间相互干扰或滥用内存。

**b.地址空间扩展**： 虚拟地址使得操作系统可以在有限的物理内存资源下支持更多的进程运行。每个进程都可以有自己的地址空间，即使物理内存有限，也可以通过页面交换等技术将不活跃的页面存储到磁盘上，从而实现更大的地址空间。

**c.内存映射和共享**： 虚拟地址使得操作系统可以更灵活地管理内存，实现内存的映射和共享。例如，多个进程可以映射同一个文件到它们的地址空间中，实现文件共享的功能

**d.地址重定位**： 虚拟地址允许操作系统在程序加载时将程序的地址空间映射到物理内存上的不同位置，从而提高系统的安全性和可移植性。这种地址重定位技术使得程序可以在不同的系统上运行而无需修改，提高了程序的可移植性和兼容

总的来说，虚拟地址提供了更高的安全性、稳定性和灵活性，使得操作系统可以更有效地管理内存资源，提高系统的性能和可用性

```c++
// 2.内存是如何分布的？
```

| 分区                 | 特点                                                         |
| -------------------- | ------------------------------------------------------------ |
| text（代码段）       | 存储的是程序源代码编译后的机器指令，是只读的                 |
| rodata（只读数据段） | 存放的是程序中的只读数据，⼀般是程序⾥⾯的只读变量和字符串常量 |
| data（数据段）       | 存放的是已经初始化了的全局静态变量和局部静态变量             |
| bss                  | 存放的是未初始化的全局静态变量和局部静态变量                 |
| 堆                   | ⼀般由程序员分配释放， 若程序员不释放，存放⼀些new创建出来的对象 |
| 栈                   | 由编译器⾃动分配释放 ，存放函数的参数值，局部变量的值等      |
| 内核空间             | 是操作系统内存管理的⼀部分，用于存储和运行操作系统内核的代码和数据 |

![image-20240610141638172](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744430.png) 

```c++
// 3.栈区和堆区的区别？
```

| 区别               | 堆                                                           | 栈                                                           |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存分配⽅式的不同 | 堆上的内存是动态分配的，程序在运行时可以根据需要分配和释放内存 | 栈上的内存是自动分配和释放的，通常用于存储函数调用过程中的局部变量、返回地址和寄存器状态等信息。当函数被调用时，栈上的内存会自动分配；当函数返回时，栈上的内存会自动释放 |
| ⽣命周期的不同     | 堆上的内存⽣命周期取决于程序员⼿动分配和释放。分配的堆内存在程序运⾏过程中⼀直存在，直到被显式释放或程序结束 | 栈上的内存⽣命周期与函数调用相关。局部变量在函数被调用时自动分配内存，函数返回时自动释放内存 |
| 内存管理的不同     | 堆上的内存需要程序员⼿动管理。程序员负责在适当的时机分配和释放内存，以避免内存泄漏和资源浪费。手动管理堆内存可能导致错误，如内存泄漏、野指针、重复释放等 | 栈上的内存由操作系统和编译器自动管理，程序员无需关⼼内存分配和释放的细节。这使得栈上的内存更容易使用，但局部变量的⽣命周期受到函数调用的限制 |
| 内存大小的不同     | 堆的大小通常比栈⼤得多，因此可以用于存储较⼤的数据结构和对象。然而，分配和释放堆内存的操作相对较慢，可能导致程序性能下降 | 栈的大小相对较⼩，适用于存储较⼩的数据结构和对象。分配和释放栈内存的操作非常快速，但栈空间有限，可能导致栈溢出错误 |

**栈何时会溢出？** 

a. 递归调用层次过深：如果一个程序中存在递归调用，而递归调用的层次过深，会导致栈空间不足，从而发生栈溢出

b. 局部变量占用过多空间：当一个函数中声明了过多的局部变量，或者某个局部变量占用的内存空间过大时，会导致栈空间快速耗尽，从而发生栈溢出

c. 大量函数调用嵌套：如果程序中存在大量的函数调用嵌套，而栈空间不足以容纳所有的函数调用信息，也会导致栈溢出

```c++
// 4.malloc是如何分配内存的？
```

**`malloc()` 并不是系统调用，而是 C 库里的函数，用于动态分配内存**   (会预分配更大的**内存池**，空间换时间)

a. **`brk()`**系统调用从堆分配内存（< 128KB）

通过 `brk() `函数将「堆顶」指针向高地址移动，获得新的内存空间，`free`后不会归还给操作系统，还是先缓存到内存池

- 频繁使用会产生内存碎片   ---为什么不只用`brk()`
- 使用内存池的内存不会触发**系统调用与缺页中断**

b. **` mmap() `**系统调用在文件映射区域分配内存（>=128KB）

通过 `mmap()` 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存，`free`后会归还给操作系统

- 每次分配都会触发**系统调用与缺页中断**，CPU消耗较大 ---为什么不只用`mmap()`

```C++
// 5.malloc和new的区别？
```

**a. 性质不同**：new是⼀个c++中特有的**操作符**，⽽malloc是c语⾔中的**内存分配函数**。New只能在c++中 使⽤，但是malloc在c++和c中都可以使⽤。
**b. 内存分配⽅式不同**：malloc分配的内存是未初始化的，⽽new不仅分配了内存，还调⽤了对象的**构造函数**来初始化对象。
**c. 使⽤语法不同**：malloc使用时需要指定分配内存的⼤⼩，如`malloc(sizeof(int))`, 但new不⽤，使⽤更加简洁，如：`new int`
**d. 返回类型**：malloc返回`void*`类型指针，需要强制转换成其它指定类型，⽽new直接返回响应的数据类型的指针，无需类型转换。
**e. 错误处理**：内存分配失败后，malloc返回`null`, ⽽new会抛出`std::bad_malloc`异常。
**f. 配对操作**：malloc分配内存使用`free`释放，⽽new分配内存要使用`delete`释放。

**==混用问题==**：混用`new`/`delete`和`malloc`/`free`会导致**未定义行为**，因为它们分配和释放内存的方式不同。例如，使用`new`分配的内存，可能包含对象的额外信息，用于正确地调用构造函数和析构函数。如果使用`free`来释放这块内存，会跳过析构函数的调用，并且可能无法正确释放内存，导致内存泄漏或其他错误。

```c++
// 6.缺页中断？
```

**定义**：当 CPU 访问的页面不在物理内存(RAM)时，便会产生一个**缺页中断**，请求操作系统将所缺页调入到物理内存。或者CPU试图执行的操作违反了内存保护规则是，也会触发缺页终端，如试图写入一个只读页或试图访问一个无权访问的页面。

**区别**：缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号；

​			缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行

```c++
// 7.页面置换算法？
```

**功能**：页面置换算法的功能是，**当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面**，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页

| 算法                           | 特点                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| a. 最佳页面置换算法            | 置换在「未来」**最长时间不访问**的页面，它的**优点**是理论上能够得到最好的性能，因为总是选择最不可能被使用的页面进行替换。**缺点**是在实践中无法实现，因为无法预知未来的访问模式。所以，最佳页面置换算法作用是为了**衡量你的算法的效率**，你的算法效率越接近该算法的效率，那么说明你的算法是高效的 |
| b. 先进先出置换算法(FIFO)      | 置换在内存**驻留时间**最长的页面，**优点**是实现简单，不需要记录页面的使⽤情况。**缺点**是可能会导致性能下降，因为最早进⼊内存的页⾯并不⼀定是最少使用的 |
| c. 最近最久未使用(LRU)置换算法 | 置换最长时间**没有被访问**的页面，**优点**是能够较好地处理局部性原理，即最近使用过的页面在未来很可能还会被使用。**缺点**是实现起来相对复杂，需要维护⼀个所有页面的使用记录列表。 |
| d. 时钟页面置换算法            | 使用⼀个环形链表和⼀个**访问位**来模拟LRU算法，表针指向的页面访问位是**0**， 就置换；是**1**就将访问位置**0**，去遍历下一个，直到找到访问位是**0**的可置换页面。**优点**是实现相对简单，同时能够得到接近LRU的性能。**缺点**是如果访问模式发⽣变化，可能会导致性能下降。 |
| e. 最不常用(LFU)置换算法       | 置换访问次数最少的页⾯，它的优点是对于长期稳定的访问模式，能够得到较好的性能。缺点是如果访问模式发⽣变化，可能会导致性能下降，因为使用频率⾼的页面可能在未来不再被访问 |



# 数据结构

## 红黑树

|          | 二叉搜索树(BST)                                              | 平衡二叉树（AVL）                                            | 红黑树 (Red-Black Tree)                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 性质     | 左子树小于根节点，右子树大于根节点                           | BST的前提下，左右子树高度差至多为1                           | BST的前提下，红黑规则，根节点黑色，无连续红节点，黑高平衡    |
| 平衡性   | 不保证平衡，最坏情况下高度为`n`                              | 高度平衡，最坏情况下高度为`logn`                             | 弱平衡(保证最长路径最多是最短路径的**2倍**)，最坏情况下高度为`2*log(n+1)`， |
| 旋转     | 不旋转                                                       | 插入时最多2次，删除时``O(logn)``，因为需要维护从被删除节点到根节点这条路径上所有节点的平衡 | ==**插入时最多2次，删除时最多3次**==                         |
| 操作效率 | 查找、插入和删除操作的平均时间复杂度为`O(log n)`，最坏为`O(n)` | 查找、插入和删除均为``O(log n)``，查找操作效率通常更高       | 查找、插入和删除均为`O(log n)`，插入删除操作效率通常更高     |
| 适用场景 | 数据分布均匀或不需要频繁插入和删除操作的场景                 | 查找操作频繁且插入和删除操作较少的场景(或者数据分布好)，需要高查找效率的应用 | ==频繁插入和删除操作==的场景，如C++ STL的map和set、I/O多路复用的epoll |

红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。

红黑树的算法时间复杂度和AVL（平衡二叉树）相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作AVL肯定会比红黑树要耗时多

**性质**:

a. 每个节点要么是红色，要么是黑色

b. 根节点总是黑色的

c. 所有的叶⼦节点（NULL节点）都是黑色的

d. 如果⼀个节点是红⾊的，那么它的两个⼦节点必须是黑色的（即不允许有连续的红色节点）

e. 从任意节点到其每个叶⼦节点的所有路径上，黑色节点的数量相同（称为黑高平衡）

## STL容器概述

### 1. vector

- **底层结构**：由 动态数组 实现 , 特点是 存储空间 连续
- **访问遍历**: 支持 随机访问迭代器 , 可使用下标访问 , 访问元素非常快 O(1) 复杂度
- **插入 / 删除** : 尾部插入 / 删除效率高 O(1)； 中间 和 头部插入/删除效率低 , 由于存储空间连续 , 需要将插入 / 删除位置之后的元素依次改变位置 , O(n)  
- **空间效率** : 底层实现时 , 会事先预留一些额外空间 , 以减少重新分配的次数 
- **使用场景** : 需要 随机访问且频繁在尾部进行操作 的场景 ; 如果频繁增删元素 则 不适用该容器 

### 2. list

- **底层结构** : 底层由 双向链表 实现 , 特点是 存储空间 不连续 
- **访问遍历** : 不支持 随机访问迭代器 , 只能通过迭代器进行访问 
- **插入 / 删除** : 任意位置 插入 / 删除 效率都很高 
- **空间效率** : 每个元素 都需要 分配额外的空间 , 存储 当前元素的 前驱元素 和 后继元素 
- **使用场景** : 需要 在任意位置 频繁 插入 / 删除 操作的 场景 

### 3. deque

+ **底层结构**: 底层由 双向队列 实现 , 特点是 存储空间 连续 
+ **访问遍历**: 支持 随机访问迭代器 , 其性能比 vector 动态素组要低 
+ **插入 / 删除** : 头部 和 尾部 插入 / 删除效率高 , O(1) ; 中间 插入/删除效率低 , 由于存储空间连续 , 需要将插入 / 删除位置之后的元素依次改变位置 , 比 vector 动态数组要快一些 
+ **空间效率** : 底层实现时比 vector 的结构要复杂 , 也会事先预留一些额外空间 , 以减少重新分配的次数 
+ **使用场景** : 需要 随机访问 且 频繁在 首部 和 尾部 进行操作 的场景 ; 如果频繁 在中部 增删元素 则 不适用该容器

### 4. set

- **底层结构**: 底层由 红黑树 实现 , 红黑树 是 一种 平衡二叉搜索树 , 存储空间 不连续
- **访问遍历** : 不支持 随机访问迭代器 , 不能通过下标访问 , 只能通过迭代器进行访问 ;
- **插入 / 删除** : 查询 / 插入 / 删除 效率 为 O(log n) 
- **排序方式** : 默认使用 less 仿函数 , 即 < 运算符(升序)进行排序 ; 也可以自定义 排序规则 仿函数 
- **使用场景** : 需要 有序集合 且 元素 不重复 的场景 (multiset 支持重复的元素)

### 5. map

- **底层结构** : 底层由 红黑树 实现 , 红黑树 是 一种 平衡二叉搜索树 , 存储空间 不连续 ; 存储的 元素 是 键值对 元素 
- **访问遍历** : 不支持 随机访问迭代器 , 不能通过下标访问 , 只能通过迭代器进行访问 
- **插入 / 删除** : 查询 / 插入 / 删除 效率 为 O(log n) 复杂度 ; 与 set 集合容器相同 
- **排序方式** : 默认使用 less 仿函数 , 即 < 运算符进行排序 ; 也可以自定义 排序规则 仿函数 ; map 映射容器 不允许重复的键 , multimap 多重映射容器允许重复的键 
- **使用场景** : 需要 有序 键值对 且 元素 不重复 的场景
- std::map 映射容器 与 std::set 集合容器 的**区别**是 map 容器存储的是 键值对 元素 , 是 pair 对象 , set 容器 存储的是 单纯的 键 单个元素 

### ![image-20240611144607976](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745039.png) 

## STL容器详解

### 1. vector

>  **“长度根据需要而自动改变的数组”**

- 定义：`vector<typename> name; vector<vector<int>> name2;`
- 容器内的访问：
  - 通过下标
  - 通过迭代器访问：`for(auto it = v.begin(); it != v.end(); it++ ) printf("%d", *it);`
- vector常用函数：
  - **push_back()**：在vector后面添加一个元素x，时间复杂度为o(1)。
  - **pop_back()**：删除vector的尾元素，时间复杂度为o(1)。
  - **size()**：获得vector中元素的个数，时间复杂度为o(1)。
  - **clear()**：用来清空vector中的所有元素，时间复杂度为o(N)。
  - **insert()**：insert(it, x)用来向vector的任意迭代器it（这是一个指针变量）处插入一个元素x，时间复杂度为o(N)。
  - **erase()**：它有两种用法：
    - 删除单个元素，erase(it)即删除迭代器为it处的元素；
    - 删除一段区间内的所有元素，erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。
- vector常见用途：
  - 储存数据：在一些元素不确定的情况下可以很好节省空间，还有在一些场合需要根据条件把部分数据输出在同一行，最后不要空格，可以用vector数组先记录，然后一次性输出。
  - 用邻接表存储图

### 2. set

> **”内部自动有序且不含重复元素的容器“**

- 定义：`set<typename> name;`   如果typename是一个容器，注意在定义时记得在>>符号之间加上空格，有些编译器会把它视为移位操作。
- set容器内元素的访问：只能通过迭代器`for(auto it = v.begin(); it != v.end(); it++ ) printf("%d", *it);`
- set常用函数：
  - **insert()**：insert(x)可将x插入set容器中，自动实现排序和去重，o(logN)。
  - **find()**：find(value)，返回set中对应值为value的容器，o(logN)。
  - **erase()**：它有两种用法：
    - 删除单个元素，st.erase(it)即删除迭代器为it处的元素，*st.erase(value)，value为要删除的元素*；
    - 删除一段区间内的所有元素，erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。
  - **size()**：获得vector中元素的个数，时间复杂度为o(1)。
  - **clear()**：用来清空set中的所有元素，时间复杂度为o(N)。
- set的常见用途：最主要的作用就是自动去重并按升序排序。

### 3. string

> **“对字符串常用需求进行了封装”**

- 定义：`string str; string str1 = "abcdef";` 要读入输出string类，只能使用cin，cout。
- 容器内的访问：
  - 通过下标
  - 通过迭代器访问：`for(auto it = v.begin(); it != v.end(); it++ ) printf("%d", *it);`
- string常用函数：
  - **operator +=**：可以直接用+号把两个string拼接起来。
  - **compare operator**：两个string类型可以直接使用==、!=、<、等比较大小，比较规则是字典序。
  - **length()/size()**：返回长度。
  - **insert()**：string的insert函数有很多写法
    - **insert(pos, string)**：在pos号位置插入字符串string。
    - **insert(it, it2, it3)**：it为原字符串的欲插入迭代器位置，it2和it3为待插入字符串的首尾迭代器，用来表示串[it2, it3)将被插入在it的位置上。
  - **erase()**：它有两种用法：
    - 删除单个元素，str.erase(it)即删除迭代器为it处的元素；
    - 删除一段区间内的所有元素，str.erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。**str.erase(pos, length)，在起始位置pos删除length个字符**。
  - **clear()**：用来清空string中的所有元素，时间复杂度为o(N)。
  - **substr()**：`str.substr(pos, len)`返回从pos号位开始，长度为len的子串。
  - **find()**：
    - `str.find(str2)`，当str2是str的子串时，返回其在str中第一次出现的位置；如果不是，返回string::npos。
    - `str.find(str2, pos)`，从str的pos位开始匹配str2，返回值同上。o(nm)。
  - **replace()**：
    - `str.replace(pos, len, str2)`把str从pos位开始、长度为len的子串替换为str2。
    - `str.replace(it1, it2, str2)`把str迭代器[it1, it2)的子串替换为str2。

### 4. map

> **“可以将任何基本类型映射到任何基本类型”**

- 定义：`map<typename1, typename2> mp;`
- 容器内的访问：
  - 通过下标`map[typename1] == typename2`
  - 通过迭代器访问:it->first 键，it->second 值
- map常用函数：
  - **find()**：`find(key)`返回键为key的映射的*迭代器*。
  - **erase()**：它有两种用法：
    - `mp.erase(it)`即删除迭代器为it处的元素。
    - `mp.erase(key)`，key为欲删除的映射的键。
    - 删除一段区间内的所有元素，mp.erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。
  - **size()**：用来获得map中映射的对数。
  - **clear()**：用来清空map中的所有元素，时间复杂度为o(N)。
- map的常见用途：
  - 需要建立字符（或字符串）与整数之间的映射，可以用map减少代码量。
  - 判断大整数或者其他类型数据是否存在，可以把map当bool用。
  - 字符串与字符串的映射。

### 5. queue

> **“有队列的常用操作封装”**

- 定义：`queue<typename> name;`
- 容器内的访问：只能通过front()，back()访问队首，队尾元素。
- queue常用函数：
  - **push()**：入队。
  - **pop()**：出队。
  - **empty()**：检测queue是否为空，返回true则空，false则非空。
  - **size()**：返回queue内元素的个数。
- queue的常见用途：广度优先搜索。

### 6. stack

> **“有栈的常用操作封装”**

- 定义：`stack<typename> name;`
- 容器内的访问：只能通过top()访问栈顶元素。
- stack常见函数：
  - **push()**：入栈。
  - **top()**：取栈顶。
  - **pop()**：出栈，弹出栈顶元素。
  - **empty()**：检测stack是否为空，返回true则空，false则非空。
  - **size()**：返回stack内元素的个数。
- stack的常见用途：模拟实现一些递归，例如DFS。

### 7. algorithm头文件下的常用函数

- **max()、min()、abs()**：前两个函数参数是两个。
- **swap()**：交换两个数的值。
- **reverse()**：reverse(it, it2)可以将数组指针在[it, it2)之间的元素或容器的迭代器在[it, it2)范围内的元素进行反转。
- **fill()**：和memset不同，这里的赋值可以是数组类型对应范围中的任意值。
- **sort()**：sort(首元素地址，尾地址的下一个元素，比较函数)。对于结构体的排序要记住。
- **lower_bound()和upper_bound()**：需要用在一个有序数组或容器中。
  - `lower_bound(first, last, val)`用来寻找数组或容器的[first, last)范围内**第一个值大于等于val的元素的值**，如果是数组，则返回该位置的指针，若是容器，则返回该位置的迭代器。
  - `upper_bound(first, last, val)`用来寻找数组或容器的[first, last)范围内**第一个值大于val的元素的值**，如果是数组，则返回该位置的指针，若是容器，则返回该位置的迭代器。



# TOOLs

## tcpdump

```shell
// 基于 IP 过滤
sudo tcpdump host 192.168.10.0 	  // 抓主机 192.168.10.0 收到和发出的所有包
sudo tcpdump dst/src 192.168.10.0 // 抓目的地/发送源是 192.168.10.0 的包
sudo tcpdump net 192.168.10.0/24  // 抓子网是 192.168.10.0/24 的包 即 192.168.10.0~255 (24表示前24位子网，剩下8位是主机)

// 基于 PORT 过滤
sudo tcpdump port 80 // 抓 80 端口的包
sudo tcpdump port 80 or 22 // 抓 80 和 22 端口的包
sudo tcpdump portrange 8000-8080 // 抓 8000-8080 的包
sudo tcpdump port http // 常见协议的默认端口可以直接使用协议名抓包 http==80 https==443

// 基于协议过滤
sudo tcpdump icmp // 抓指定协议的包 一般常用：ip、ip6、arp、icmp、tcp、udp 等
sudo tcpdump port http // 应用层协议 http、dns、https、ssh 等，不能直接按上面那样按协议过滤，需要通过端口过滤

// 常用参数
sudo tcpdump -h // 查看所有参数
sudo tcpdump -i eth0/any // 抓指定网卡的包 eth0/所有网卡
sudo tcpdump -i eth0 -w test.pcap // 抓eth0网卡的包并保存成 test.pcap 文件  ifconfig 可查看网卡信息
sudo tcpdump -r test.pacp // 从 test.pcap 文件读取数据

sudo tcpdump -n // 不将ip转为域名，直接显示ip，避免执行DNS lookups 的过程，速度会快很多
sudo tcpdump -nn // 不把协议和端口转为名字，速度也会快很多
sudo tcpdump -t // 在每行的输出中不输出时间
sudo tcpdump -tt // 在每行的输出中打印时间戳(自1970年1月1日以来的时间（通常称为UNIX时间戳），单位为秒和微秒)
sudo tcpdump -ttt // 输出每两行打印的时间间隔(以毫秒为单位)
sudo tcpdump -tttt // 在每行答应的时间戳之前添加日期的打印

sudo tcpdump -v // 产生详细的输出，如包的TTL，id标识，数据包长度 -vv 更详细  -vvv更更详细
sudo tcpdump -c // 指定抓包次数，收到指定数量的包后退出tcpdump 停止抓包
sudo tcpdump -C // 与-w配合使用，比如 tcpdump -C 1 -W 3 -w abc 指定抓满1MB就换文件，最多写3个文件，名字是abc0 abc1 abc2
sudo tcpdump -q // 简洁地打印输出 只显示基本的摘要信息，减少冗长的详细信息
sudo tcpdump -Q // 指定抓包方向 tcpdump -Q in/out/inout 进入/离开/所有方向
sudo tcpdump -D // 列出系统中所有可用的网络接口

sudo tcpdump -s // 指定每个数据包的捕获长度(单位：字节) 即只捕获每个包的前n个字节
sudo tcpdump -A // 将捕获的数据包内容以 ASCII 格式打印出来。这个选项特别有用，可以查看数据包中的文本数据，例如 HTTP 请求和响应内容、明文协议的数据
sudo tcpdump -X // 以十六进制和 ASCII 格式显示捕获的数据包内容。这个选项特别有用，可以查看数据包的详细内容，包括非文本数据
sudo tcpdump -e // 显示源和目的MAC地址

sudo tcpdump -F // 从指定的文件读取过滤表达式，而不是直接在命令行中输入过滤表达式,方便过滤表达式管理和重用

// 过滤规则逻辑运算
sudo tcpdump src 100.100.30.26 and port 80 // 抓来自100.100.30.26主机且端口是80的包
sudo tcpdump tcp port 53 or udp port 53 // 抓UDP 53端口或者TCP 53端口的包(DNS协议的报文)
sudo tcpdump not tcp port 22 // 抓不是22端口的报文 not == ！
sudo tcpdump "src 10.0.2.4 and (dst port 3389 or 22)" // 抓源 IP 地址为 10.0.2.4，并且目标端口为 3389 或 22 的数

// 基于大小过滤
sudo tcpdump less 32 // 抓包小于 32 个字节的包
sudo tcpdump greater 300 // 抓包大于 32 个字节的包
```

## CMAKE

- `# `注释一行  `#[[]]` 注释多行

```cmake
# 这是一个 CMakeLists.txt 文件
cmake_minimum_required(VERSION 3.0.0)

#[[ 这是一个 CMakeLists.txt 文件。
这是一个 CMakeLists.txt 文件
这是一个 CMakeLists.txt 文件]]
cmake_minimum_required(VERSION 3.0.0)
```

- `CMakeLists.txt` ：`touch CMakeLists.txt`

```cmake
# 指定使用的 cmake 的最低版本 可选 不加可能警告
cmake_minimum_required(VERSION 3.0) 
# 定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言
project(CALC) 
# 定义工程会生成一个可执行程序，第一个是生成的可执行文件名，后面是源文件名称
add_executable(app add.c div.c main.c mult.c sub.c) # 源文件名可以是一个也可以是多个，如有多个可用空格或;间隔
add_executable(app add.c;div.c;main.c;mult.c;sub.c) 
```

- 生成`makefile`

```shell
cmake ./CMakeLists.txt # CMakeLists.txt路径
make # 再执行make命令，就可以对项目进行构建得到所需的可执行程序了
```

- 创建build文件夹，将 cmake 过程中于源码无关的文件统一放置

```shell
mkdir build
cd build
cmake .. // 在build目录中会生成一个makefile文件
make // 完成编译，将cmake和make生成的所有文件和项目源文件隔离
```

- 定义变量：假设源文件需要重复使用，可定义变量将文件名对应的字符串存储

```cmake
# SET 指令的语法是：
# [] 中的参数为可选项, 如不需要可以不写
SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) # VAL 变量名 VALUE 变量值
```

- 指定使用的 C++ 标准

```cmake
# 方法1：在 CMakeLists.txt 中通过 set 命令指定
#增加-std=c++11
set(CMAKE_CXX_STANDARD 11)
#增加-std=c++14
set(CMAKE_CXX_STANDARD 14)
#增加-std=c++17
set(CMAKE_CXX_STANDARD 17)

# 方法2：在执行 cmake 命令的时候指定出这个宏的值
#增加-std=c++11
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11
#增加-std=c++14
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14
#增加-std=c++17
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17

# CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。
# PROJECT_SOURCE_DIR 宏表示当前的根目录
```

- 指定输出的路径

```cmake
set(HOME /home/robin/Linux/Sort) # 定义一个变量用于存储一个绝对路径 如果路径不存在会创建
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin) # 将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏
```

- 搜索文件

```cmake
# 方法1：  aux_source_directory(< dir > < variable >) # dir:要搜索的目录 variable:将从 dir 目录下搜索到的源文件列表存储到该变量中
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)


# 方法2： file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型) 
#        GLOB 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中
# 		 GLOB_RECURSE 递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中
file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
```

- 包含头文件：将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件

```cmake
include_directories(headpath) # headpath即头文件存放路径

cmake_minimum_required(VERSION 3.0) # 版本
project(CALC) 						# 项目名
set(CMAKE_CXX_STANDARD 11)          # C++ 标准
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin/) # 输出路径
include_directories(${PROJECT_SOURCE_DIR}/include) # 指定头文件路径
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp) # 搜索 /src 下所有 .cpp 
add_executable(app  ${SRC_LIST}) # 生成可执行文件
```

- 制作静态库：在Linux中，静态库名字分为三部分：**lib+库名字+.a**，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充

```cmake
add_library(库名称 STATIC 源文件1 [源文件2] ...) 
```

- 制作动态库：在Linux中，动态库名字分为三部分：**lib+库名字+.so**，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充

```cmake
add_library(库名称 SHARED 源文件1 [源文件2] ...) 
```

- 指定静态库、动态库生成输出路径

```cmake
# 设置动态库/静态库生成路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
# 生成动态库
#add_library(calc SHARED ${SRC_LIST})
# 生成静态库
add_library(calc STATIC ${SRC_LIST})
```

- 链接静态库

```cmake
link_directories(<lib path>)
# 如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来
link_libraries(<static lib> [<static lib>...]) 
# para1:要链接的静态库的名,可以是全名也可以是库名 para2:要链接的其它静态库的名字
```

- 链接动态库

```cmake
link_directories(<lib path>)
# 如果该动态库不是系统提供的（自己制作或者使用第三方提供的动态库）可能出现动态库找不到的情况，此时可以将动态库的路径也指定出来
target_link_libraries(
    <target> 
    <PRIVATE|PUBLIC|INTERFACE> <item>... 
    [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)
# para1：指定要加载动态库的文件的名字 para2:动态库的访问权限，默认为PUBLIC

# 在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后
# 静态库：链接阶段被复制到可执行文件中(.text .data .bss...),所以可执行程序一启动，静态库就被加载到内存中了
# 动态库：链接阶段只复制 重定位和符号表信息 可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存
```



## GIT



# CV

- 熟练使用C/C++，熟悉面向对象编程，掌握C++11新特性(智能指针等)以及内存管理，理解泛型编程及RAII思想
- 熟悉数组、链表、栈、二叉树、哈希表等常用数据结构，熟悉查找、排序、DFS、DP等算法
- 熟悉Linux下socket网络编程，掌握Linux下I/O多路复用技术，对epoll模型有较深理解，了解Reactor模式
- 熟悉Linux下多进程、多线程编程，熟悉进程间通信以及线程间同步互斥机制，理解线程安全
- CMAKE?GDB? 
- 熟悉TCP/IP网络模型，熟悉常见的网络协议，如HTTP、HTTPS、TCP、IP等，会使用tcpdump + wireshark进行基础的抓包分析
- `熟悉深度学习基础知识，了解CNN、Transformer等神经网络原理，熟悉深度学习的训练与测试流程`



项目1：Linux下高并发HTTP服务器

项目描述：在Linux系统下开发的HTTP服务器，基于多进程实现用户接入、业务处理、日志与数据库，使用epoll和线程池的方式实现高并发。

- 基于多态、C++11新特性`(std::bind、std::function、可变参数模板)`与泛型编程思想实现了可调用对象模版类，用于承接不同类型的函数指针和函数参数以生成对应的可调用对象，实现各进程对象与线程对象可接入任意函数作为任务函数
- 封装套接字类，将C/S通信流程抽象为五个对外接口，支持本地/网络、UDP/TCP、监听/连接等套接字的创建，屏蔽了不同类型套接字的区别
- 封装线程池类，对外提供开启、任务添加和关闭接口，对内基于本地套接字和epoll来分发任务，无需引入需要加锁的任务队列，规避了线程池中多线程竞争任务带来的同步互斥问题
- 用户接入模块基于Reactor网络模式，利用epoll的高效事件通知机制和线程池的并发处理能力，只负责处理网络用户的接入请求，随后将连接全分发给业务处理模块做后续处理
- 针对实际应用中业务需求易变更、内容繁杂等特点，通过接口类来解耦用户接入与业务处理，业务处理模块通过继承业务接口类来完成具体的业务处理
- 设计了分级日志模块，通过构造函数与运算符重载以支持普通日志和流式日志，结合宏定义简化了各模块写日志流程
- 封装MySQL数据库表类与列类，实现对象关系映射，同时利用MD5加密来提高用户登录的安全性

 
